<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>两招</title>
        <description>两招 - Jianhua Zhang</description>
        <link>http://www.jeffzhang.cn</link>
        <link>http://www.jeffzhang.cn</link>
        <lastBuildDate>2014-05-15T17:03:55+08:00</lastBuildDate>
        <pubDate>2014-05-15T17:03:55+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>Scrum Summary</title>
                <description>
&lt;h2 id=&quot;scrum&quot;&gt;Scrum的核心价值观&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;承诺、专注、公开、敬重和勇气。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;scrum-1&quot;&gt;Scrum总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;团队和项目出资人创建一个团队需要做的所有事情的列表。这可以是一个任务的列表或者特性的列表。这就是Product Backlog。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个月，团队都努力实现列表最顶端的任务，这一部分是他们估计需要一个月完成的工作。他们把它展开成一个详细的任务列表，叫做Sprint Backlog。这个团队承诺在月底向出资人演示或交付结果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每天，团队都面对面地开5～10分钟的会，彼此更新各自的状态和排除使他们减慢的路障。这个叫Daily stand-up meeting。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定一个特别的人担任Scrum Master，这个人的任务是排除或安排别人排除在例会上这个团队提到的任何路障。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://www.jeffzhang.cn/software%20engineering/2014/05/15/Scrum-summary</link>
                <guid>http://www.jeffzhang.cn/software%20engineering/2014/05/15/Scrum-summary</guid>
                <pubDate>2014-05-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Notes(11). Workflows In Openerp</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;工作流简介&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;工作流程系统在OpenERP里是非常有用的机制，可以用于及时描述文件(模型)的演进过程。&lt;/li&gt;
  &lt;li&gt;工作流程是完全可以定制的，这些流程可以调整适用于几乎所有公司的作业流程和交易逻辑。 这个工作流程系统使OpenERP非常有弹性，而且可以不用编程增加新功能,就可以支持不断变化的需要。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://doc.openerp.com/6.1/zh_CN/developer/07_workflows/&quot;&gt;官方工作流文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工作流的目标&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;及时描述文件的演进&lt;/li&gt;
  &lt;li&gt;符合某些条件时自动触发动作&lt;/li&gt;
  &lt;li&gt;管理公司里人员的角色和验证步骤&lt;/li&gt;
  &lt;li&gt;管理不同物件/模块间的互动&lt;/li&gt;
  &lt;li&gt;为文件流程可视化提供图形化的工具&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;内容&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;查看OE业务友好的工作流视图;&lt;/li&gt;
  &lt;li&gt;使用OE图形化的工作流编辑器检查销售订单工作流;&lt;/li&gt;
  &lt;li&gt;学习OE中如何用活动(activities)和变迁(transitions)管理文档状态;&lt;/li&gt;
  &lt;li&gt;学习如何对一个现实的例子修改工作流: 订单确认前增加一个批准过程.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;查看销售订单工作流&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;激活开发模式, 销售-&amp;gt;销售订单顶部, 销售订单标签右侧有个小问号图标, 点它查看销售订单业务流程.&lt;/li&gt;
  &lt;li&gt;每个矩形是一个节点, 包含工作流过程中的一个步骤; 箭头指出信息在工作流中流动的方向.&lt;/li&gt;
  &lt;li&gt;背景有环形符号的节点表示该节点包含子工作流.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;点击左下角的蓝色信息图标可以跳转到OpenERP网站的相关帮助内容&lt;/em&gt;
&lt;em&gt;点击右下角的绿色箭头图标可以跳转到该节点对应的OpenERP模型&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;oe&quot;&gt;工作流在OE中能干什么?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;修改文档当前的状态或阶段;&lt;/li&gt;
  &lt;li&gt;确定执行一个过程所需的文档状态条件;&lt;/li&gt;
  &lt;li&gt;基于用户角色和访问权限确定处理方式;&lt;/li&gt;
  &lt;li&gt;创建子工作流来封装复杂性.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;工作流设计器&lt;/h2&gt;

&lt;p&gt;Debug模式下, 销售-&amp;gt;销售订单顶部销售订单标签左侧下拉框选择编辑工作流, 将显示工作流列表, 在右侧选择图表视图即可出现编辑工作流可视化编辑器.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;灰色节点表示它是工作流的开始或结束节点.&lt;/p&gt;
</description>
                <link>http://www.jeffzhang.cn/openerp/2014/05/14/OpenERP-Notes%2811%29.-workflows-in-OpenERP</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/05/14/OpenERP-Notes(11).-workflows-in-OpenERP</guid>
                <pubDate>2014-05-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Dev Notes (8). Custom Module Development 2</title>
                <description>
&lt;h1 id=&quot;section&quot;&gt;编写一个培训管理模块&lt;/h1&gt;

&lt;p&gt;参考: &lt;a href=&quot;http://www.openerp-china.org/index.php?page=developer&quot;&gt;oecn_training&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;需求描述&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;输入和查询课程,把信息储存到课程对象里&lt;/li&gt;
  &lt;li&gt;课程包含以下信息：名称，价格，天数，开始日期，教师，学员&lt;/li&gt;
  &lt;li&gt;每个课程可以有多个学员，要记录学员的姓名、电话、电子邮件&lt;/li&gt;
  &lt;li&gt;课程可以添加教材和作业等文档附件&lt;/li&gt;
  &lt;li&gt;用户可以设置默认值以加速输入&lt;/li&gt;
  &lt;li&gt;可以按名称查询课程，也可以用其他信息查找课程，并保存常用查询条件&lt;/li&gt;
  &lt;li&gt;可以导出课程信息到excel文件，并支持导入&lt;/li&gt;
  &lt;li&gt;可以按日期查看课程，并调整课程时间&lt;/li&gt;
  &lt;li&gt;老师只能看到自己的课程&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;编写课程模块&lt;/h2&gt;

&lt;h3 id=&quot;pycharm&quot;&gt;PyCharm中创建工程&lt;/h3&gt;

&lt;p&gt;PyCharm中创建一个工程my_training, 存放在OE addons目录下, 并在该工程中打开OE目录(见之前的文章).&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;文件结构&lt;/h3&gt;

&lt;p&gt;模块名命名为”my_training”, 目录下四个文件, 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|--my_training
     |--__init__.py
     |--__openerp__.py
     |--lesson.py
     |--lesson_view.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;initpy&quot;&gt;__init__.py&lt;/h3&gt;

&lt;p&gt;Python模块描述文件, 每个OE模块也是一个Python模块.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
import lesson
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;openerppy&quot;&gt;__openerp__.py&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
{
    &quot;name&quot;: &quot;My Training&quot;, #模块名
    &quot;version&quot;: &quot;1.0&quot;,        #模块版本
    &quot;description&quot;: &#39;My Training Demo&#39;, #模块说明
    &quot;author&quot;: &quot;Jeff&quot;,    #作者
    &quot;website&quot;: &quot;http://www.jeffzhang.cn&quot;, #网址
    &quot;depends&quot;: [],                      #依赖的模块
    &quot;data&quot;: [&quot;lesson_view.xml&quot;],
    &quot;demo&quot;: [],
    &quot;installable&quot;: True,                #可否安装
    &#39;auto_install&#39;: False,
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lessonpy&quot;&gt;lesson.py&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 &amp;gt;-*-

from openerp.osv import fields, osv

class my_training_lesson(osv.osv):
    _name = &#39;my.training.lesson&#39;
    _discription = u&#39;培训课程示例&#39;
    _columns = {
        &#39;name&#39;: fields.char(u&#39;课程名&#39;,size=64, select=True),
        &#39;date_start&#39;: fields.date(u&#39;开始日期&#39;, select=True),
        &#39;total_day&#39;: fields.float(u&#39;总天数&#39;, digits=(16,1)),
        &#39;teacher&#39;: fields.many2one(&#39;res.users&#39;, u&#39;授课老师&#39;),
        &#39;students&#39;: fields.many2many(&#39;res.partner&#39;, string=u&#39;学生&#39;),
        &#39;price&#39;: fields.float(u&#39;价格&#39;, digits=(16,2)),
    }

my_training_lesson()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lessonviewxml&quot;&gt;lesson_view.xml&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;openerp&amp;gt;
    &amp;lt;data&amp;gt;
    &amp;lt;!--定义表单视图--&amp;gt;
        &amp;lt;record model=&quot;ir.ui.view&quot; id=&quot;my_training_lesson_form_view&quot;&amp;gt;
            &amp;lt;field name=&quot;name&quot;&amp;gt;课程表单&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;type&quot;&amp;gt;form&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;model&quot;&amp;gt;my.training.lesson&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;arch&quot; type=&quot;xml&quot;&amp;gt;
                &amp;lt;form string=&quot;课程表单&quot;&amp;gt;
                    &amp;lt;field name=&quot;name&quot;/&amp;gt;
                    &amp;lt;field name=&quot;date_start&quot;/&amp;gt;
                    &amp;lt;field name=&quot;total_day&quot;/&amp;gt;
                    &amp;lt;field name=&quot;price&quot;/&amp;gt;
                    &amp;lt;field name=&quot;teacher&quot;/&amp;gt;
                    &amp;lt;field name=&quot;students&quot; colspan=&quot;4&quot;/&amp;gt;
                &amp;lt;/form&amp;gt;
            &amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
        &amp;lt;!--定义列表视图--&amp;gt;
        &amp;lt;record model=&quot;ir.ui.view&quot; id=&quot;my_training_lesson_tree_view&quot;&amp;gt;
            &amp;lt;field name=&quot;name&quot;&amp;gt;课程列表&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;type&quot;&amp;gt;tree&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;model&quot;&amp;gt;my.training.lesson&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;arch&quot; type=&quot;xml&quot;&amp;gt;
                &amp;lt;tree string=&quot;课程列表&quot;&amp;gt;
                    &amp;lt;field name=&quot;name&quot;/&amp;gt;
                    &amp;lt;field name=&quot;date_start&quot;/&amp;gt;
                    &amp;lt;field name=&quot;teacher&quot;/&amp;gt;
                    &amp;lt;field name=&quot;price&quot; sum=&quot;合计&quot;/&amp;gt;
                &amp;lt;/tree&amp;gt;
            &amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
&amp;lt;!--定义视图动作--&amp;gt;
    &amp;lt;record model=&quot;ir.actions.act_window&quot;  id=&quot;action_my_training_lesson&quot;&amp;gt;
        &amp;lt;field name=&quot;name&quot;&amp;gt;课程&amp;lt;/field&amp;gt;    &amp;lt;!--这个字符串即课程对应列表或编辑界面的标题--&amp;gt;
        &amp;lt;field name=&quot;res_model&quot;&amp;gt;my.training.lesson&amp;lt;/field&amp;gt;
        &amp;lt;field name=&quot;view_type&quot;&amp;gt;form&amp;lt;/field&amp;gt;
        &amp;lt;field name=&quot;view_mode&quot;&amp;gt;form,tree&amp;lt;/field&amp;gt;
        &amp;lt;field name=&quot;view_id&quot; ref=&quot;my_training_lesson_tree_view&quot;/&amp;gt;
    &amp;lt;/record&amp;gt;
&amp;lt;!--定义菜单--&amp;gt;
    &amp;lt;menuitem id=&quot;my_menu&quot; name=&quot;培训示例&quot;/&amp;gt;
    &amp;lt;menuitem id=&quot;my_training_menu&quot; name=&quot;培训&quot; parent=&quot;my_menu&quot;/&amp;gt;
    &amp;lt;menuitem id=&quot;my_training_lesson_menu&quot; name=&quot;培训课程&quot; parent=&quot;my_training_menu&quot; action=&quot;action_my_training_lesson&quot;/&amp;gt;
&amp;lt;/data&amp;gt;
&amp;lt;/openerp&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;通过继承修改模块&lt;/h2&gt;

&lt;p&gt;Custom Module Development第一部分中说明了怎么扩展一个系统模块, 这部分扩展刚才编写的课程模块.&lt;/p&gt;

&lt;h3 id=&quot;pycharm-1&quot;&gt;PyCharm中创建工程&lt;/h3&gt;

&lt;p&gt;PyCharm中创建一个工程my_training_classroom, 存放在OE addons目录下, 并在该工程中打开OE目录(见之前的文章).&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;文件结构&lt;/h3&gt;

&lt;p&gt;模块名命名为”my_training_classroom”, 目录下六个文件, 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|--my_training_classroom
     |--__init__.py
     |--__openerp__.py
     |--lesson.py  #继承my.training.lesson对象的文件
     |--classroom.py
     |--lesson_view.xml
     |--classroom_view.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;initpy-1&quot;&gt;__init__.py&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
import lesson
import classroom
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;openerppy-1&quot;&gt;__openerp__.py&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
{
    &quot;name&quot;: &quot;My Training Classroom&quot;, #模块名
    &quot;version&quot;: &quot;1.0&quot;,        #模块版本
    &quot;description&quot;: &#39;My Training Demo -- ClassRoom&#39;, #模块说明
    &quot;author&quot;: &quot;Jeff&quot;,    #作者
    &quot;website&quot;: &quot;http://www.jeffzhang.cn&quot;, #网址
    &quot;depends&quot;: [&quot;my_training&quot;],                      #依赖的模块
    &quot;data&quot;: [
        &quot;lesson_view.xml&quot;,      # 需要继承的视图
        &quot;classroom_view.xml&quot;,],   # 模块更新时读入的文件
    &quot;demo&quot;: [],
    &quot;installable&quot;: True,                #可否安装
    &#39;auto_install&#39;: False,
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;classroompy&quot;&gt;classroom.py&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;from openerp.osv import fields, osv

class my_training_classroom(osv.osv):
    _name = &#39;my.training.classroom&#39;
    _discription = u&#39;教室&#39;
    _columns = {
        &#39;number&#39;: fields.char(u&#39;编号&#39;, size=64, select=True),
        &#39;capacity&#39;: fields.integer(u&#39;容纳人数&#39;, select=True),
        &#39;location&#39;: fields.char(u&#39;地点&#39;, size=125, select=True),
    }
my_training_classroom()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lessonpy-1&quot;&gt;lesson.py&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;from openerp.osv import fields, osv

class my_training_lesson(osv.osv):
    _name = &#39;my.training.lesson&#39;  #本对象的名称
    _inherit = &#39;my.training.lesson&#39;  #要继承的对象的_name
    _columns = {
       &#39;classroom_id&#39;: fields.many2one(&#39;my.training.classroom&#39;, u&#39;教室&#39;), #添加一个教室属性，为多对一对象。
    }

my_training_lesson()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lessonviewxml-1&quot;&gt;lesson_view.xml&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml versi&amp;gt;on=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;openerp&amp;gt;
    &amp;lt;data&amp;gt;
        &amp;lt;!--教室--&amp;gt;
            &amp;lt;record model=&quot;ir.ui.view&quot; id=&quot;my_training_lesson_from_inherit_classroom_view&quot;&amp;gt;
            &amp;lt;field name=&quot;name&quot;&amp;gt;课程教室继承视图&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;type&quot;&amp;gt;form&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;model&quot;&amp;gt;my.training.lesson&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;inherit_id&quot; ref=&quot;my_training.my_training_lesson_from_view&quot;/&amp;gt;
            &amp;lt;field name=&quot;arch&quot; type=&quot;xml&quot;&amp;gt;
                &amp;lt;field name=&quot;name&quot; position=&quot;after&quot;&amp;gt;
                    &amp;lt;field name=&quot;classroom_id&quot;/&amp;gt;
                &amp;lt;/field&amp;gt;
            &amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
    &amp;lt;/data&amp;gt;
&amp;lt;/openerp&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;classroomviewxml&quot;&gt;classroom_view.xml&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;openerp&amp;gt;
    &amp;lt;data&amp;gt;
        &amp;lt;!--教室--&amp;gt;
            &amp;lt;record model=&quot;ir.ui.view&quot; id=&quot;my_training_classroom_from_view&quot;&amp;gt;
            &amp;lt;field name=&quot;name&quot;&amp;gt;教室&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;type&quot;&amp;gt;form&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;model&quot;&amp;gt;my.training.classroom&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;arch&quot; type=&quot;xml&quot;&amp;gt;
                &amp;lt;form string=&quot;教室表单&quot;&amp;gt;
                    &amp;lt;field name=&quot;number&quot;/&amp;gt;
                    &amp;lt;field name=&quot;capacity&quot;/&amp;gt;
                    &amp;lt;field name=&quot;location&quot; /&amp;gt;
                &amp;lt;/form&amp;gt;
            &amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
         &amp;lt;!--定义列表视图--&amp;gt;
        &amp;lt;record model=&quot;ir.ui.view&quot; id=&quot;my_training_classroom_tree_view&quot;&amp;gt;
            &amp;lt;field name=&quot;name&quot;&amp;gt;教室列表&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;type&quot;&amp;gt;tree&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;model&quot;&amp;gt;my.training.classroom&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;arch&quot; type=&quot;xml&quot;&amp;gt;
                &amp;lt;tree string=&quot;教室列表&quot;&amp;gt;
                    &amp;lt;field name=&quot;number&quot;/&amp;gt;
                    &amp;lt;field name=&quot;capacity&quot; /&amp;gt;
                    &amp;lt;field name=&quot;location&quot; /&amp;gt;
                &amp;lt;/tree&amp;gt;
            &amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
&amp;lt;!--定义视图动作--&amp;gt;
    &amp;lt;record model=&quot;ir.actions.act_window&quot;  id=&quot;action_my_training_classroom&quot;&amp;gt;
        &amp;lt;field name=&quot;name&quot;&amp;gt;教室&amp;lt;/field&amp;gt;
        &amp;lt;field name=&quot;res_model&quot;&amp;gt;my.training.classroom&amp;lt;/field&amp;gt;
        &amp;lt;field name=&quot;view_type&quot;&amp;gt;form&amp;lt;/field&amp;gt;
        &amp;lt;field name=&quot;view_mode&quot;&amp;gt;form,tree&amp;lt;/field&amp;gt;
        &amp;lt;field name=&quot;view_id&quot; ref=&quot;my_training_classroom_tree_view&quot;/&amp;gt;
    &amp;lt;/record&amp;gt;
&amp;lt;!--定义菜单--&amp;gt;
        &amp;lt;menuitem id=&quot;my_training_classroom_menu&quot; name=&quot;教室&quot; parent=&quot;my_training.my_training_menu&quot; action=&quot;action_my_training_classroom&quot;/&amp;gt;
    &amp;lt;/data&amp;gt;
&amp;lt;/openerp&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://www.jeffzhang.cn/openerp/2014/05/07/OpenERP-DEV-Notes-%288%29.-Custom-Module-Development-2</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/05/07/OpenERP-DEV-Notes-(8).-Custom-Module-Development-2</guid>
                <pubDate>2014-05-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Dev Faq. Invalid Xml For View Architecture</title>
                <description>
&lt;h2 id=&quot;working-with-oe&quot;&gt;1. 2014-05-05, working with OE例子&lt;/h2&gt;

&lt;p&gt;working with OE开发部分, 在sales order的view后加两个字段.&lt;/p&gt;

&lt;p&gt;安装模块时一直出现”Invalid XML for View Architecture!”错误, 查了很多情况不知为什么, 最后将xml文件内容copy到vi中, 发现有乱码, 乱码的原因是直接copy了pdf中的文本, 删除乱码, 解决了.&lt;/p&gt;

</description>
                <link>http://www.jeffzhang.cn/openerp/2014/05/05/OpenERP-DEV-FAQ.-Invalid-XML-for-View-Architecture</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/05/05/OpenERP-DEV-FAQ.-Invalid-XML-for-View-Architecture</guid>
                <pubDate>2014-05-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Dev Notes (7). Custom Module Development 1</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;目标&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;OpenERP模块基本结构&lt;/li&gt;
  &lt;li&gt;使用模块添加额外的字段(Date Required和Rush Order)&lt;/li&gt;
  &lt;li&gt;扩展视图, 让OpenERP能够显示新的字段&lt;/li&gt;
  &lt;li&gt;修改用于OpenERP工作流的可用状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;openerp&quot;&gt;创建第一个OpenERP模块&lt;/h2&gt;
&lt;p&gt;不修改OE源码情况下写自己的模块扩展OE是OpenERP框架一个很好的特性. 我们所做的所有修改都放在我们自己的目录, 自己的文件中.&lt;/p&gt;

&lt;p&gt;每个OE模块能够被OE框架正确认识并安装, 一旦成功安装了我们的模块, OE框架将会用该模块的功能扩展OE.&lt;/p&gt;

&lt;h2 id=&quot;oe&quot;&gt;指定一个目录保存我们的OE模块&lt;/h2&gt;

&lt;p&gt;两种方式:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在OE的addons目录下保存我们的模块;&lt;/li&gt;
  &lt;li&gt;创建一个独立的目录保存我们的模块, 这种方式的有点是能够将OE标准模块与我们的模块分开.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于第二种方式, 需要修改OE的配置文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[options]
admin_passwd = admin
db_user = jeff
db_password = greater
addons_path = /home/openerp/server/addons,/home/mymodules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样, home目录下的mymodules目录中保存我们定制的OE模块.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;模块目录内容&lt;/h2&gt;

&lt;p&gt;在OE的addos目录下(addons_path中设定)创建一个目录silkworm保存我们的silkworm模块. 在silkworm目录下创建两个文件:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;__init__.py&lt;/li&gt;
  &lt;li&gt;__openerp__.py&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;__init__.py文件的目的是指定该模块中想要包含的Python文件(不用管文件的扩展名).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import silkworm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;__openerp__.py文件是OE模块的清单文件, 向OE框架说明该模块的一些属性. 这个文件有时也被称为模块描述文件, 用Python中的字典(dictionary)描述.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
       &#39;name&#39;: &#39;Screen Printing&#39;,
       &#39;version&#39;: &#39;1.0&#39;,
       &#39;description&#39;: &quot;&quot;&quot;
       This module adds functionality for
            screen printing companies
       &quot;&quot;&quot;,
       &#39;author&#39;: &#39;Greg Moss&#39;,
       &#39;depends&#39;: [&#39;base&#39;,&#39;sale&#39;],
       &#39;data&#39;: [&#39;silkworm_view.xml&#39;],
       &#39;demo&#39;: [],
       &#39;installable&#39;: True,
       &#39;auto_install&#39;: False,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在安装OpenERP模块时, __openerp__.py文件给出框架配置该模块所需的各种信息.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;name: 显示在OpenERP模块列表中;&lt;/li&gt;
  &lt;li&gt;version: 模块版本号;&lt;/li&gt;
  &lt;li&gt;description: 安装模块时显示;&lt;/li&gt;
  &lt;li&gt;author: 作者;&lt;/li&gt;
  &lt;li&gt;depends: 前面几项(name, version等)是用于文档的说明性的元素, depends告诉框架这个模块是建构在哪些其他模块基础上的. 至少要依赖于base, 本例中因为扩展了sales order系统, 所以也要依赖于sale模块;&lt;/li&gt;
  &lt;li&gt;data: 指定模块的xml视图文件. 如果希望改变OE的forms或UI, 创建一个视图文件. 其他类型的数据文件也可以在这里指定, 例如包含初始化数据或访问权限的数据. 本例中只有一个文件silkworm_view.xml文件;&lt;/li&gt;
  &lt;li&gt;demo: OE提供了一种方便的方式来包含定制模块的说明数据, 本例中留空, 但是如果希望在模块安装时可以添加一些说明数据, 用这项指定;&lt;/li&gt;
  &lt;li&gt;installable: 使用此项可以临时禁止一个模块的安装;&lt;/li&gt;
  &lt;li&gt;auto_install: 如果此项为True, OE将会在该模块的所有依赖项安装好之后自动安装这个模块, 大部分情况下不会指定自动安装.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;silkwormpyopenerp&quot;&gt;silkworm.py中扩展OpenERP模型&lt;/h2&gt;

&lt;p&gt;为了向我们的sales order添加Date Required和Rush Order字段, 首先创建silkworm.py文件, 然后添加下面的代码到silkworm.py文件中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from openerp.osv import osv, fields

class silkworm_sale_order(osv.Model):
    _inherit = &#39;sale.order&#39;
    _columns = {
       &#39;x_daterequired&#39;: fields.date(&#39;Date Required&#39;, required=True),
       &#39;x_rush&#39;: fields.boolean(&#39;Rush Order&#39;),
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sales-order&quot;&gt;继承sales order&lt;/h3&gt;

&lt;p&gt;代码中, 创建了一个silkworm_sale_order类, 派生自osv.Model, Python的OO继承.&lt;/p&gt;

&lt;p&gt;_inherit_ = ‘sale.order’, 这一句指出这个类继承了sale.order, OpenERP的继承.&lt;/p&gt;

&lt;p&gt;_columns字典列出了我们向sales order模块添加的两个自定义字段.&lt;/p&gt;

&lt;h3 id=&quot;sales-order-1&quot;&gt;将自定义字段添加到sales order视图中&lt;/h3&gt;

&lt;p&gt;__openerp__.py文件中的’data’指定了视图xml文件, silkworm_view.xml.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
   &amp;lt;openerp&amp;gt;
       &amp;lt;data&amp;gt;
          &amp;lt;record id=&quot;sale_view_order_form&quot; model=&quot;ir.ui.view&quot;&amp;gt;
            &amp;lt;field name=&quot;model&quot;&amp;gt;sale.order&amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;inherit_id&quot; ref=&quot;sale.view_order_form&quot;/&amp;gt;
            &amp;lt;field name=&quot;arch&quot; type=&quot;xml&quot;&amp;gt;
              &amp;lt;field name=&quot;client_order_ref&quot; position=&quot;after&quot;&amp;gt;
                &amp;lt;field name=&quot;x_daterequired&quot;/&amp;gt;
                &amp;lt;field name=&quot;x_rush&quot;/&amp;gt;
              &amp;lt;/field&amp;gt;
            &amp;lt;/field&amp;gt;
       &amp;lt;/record&amp;gt;
    &amp;lt;/data&amp;gt;
&amp;lt;/openerp&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OE中的视图定义使用XML语法. OE视图文件用openerp标记包裹, 下一级是data标记. 为了在自定义的OE模块中修改或添加视图, 添加record标记.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;record id=&quot;sale_view_order_form&quot; model=&quot;ir.ui.view&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个record必须有一个id属性, 另外这里我们指定了这个record的model属性为ir.ui.view.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;field name=&quot;model&quot;&amp;gt;sale.order&amp;lt;/field&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来, 应该指定这个record对应的model, 本例中为sale.order, 因为我们为sale.order添加了字段. 如果我们为purchase order添加了字段, 那这里就应该是purchase.order.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在OE的开发模式下, 鼠标移动到字段上可以查看该字段所属的模型; 在开发模式下的Manage Views中, 也可以发现想要使用的view的名字. 这些功能可以方便OpenERP的模块开发.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;field name=&quot;inherit_id&quot; ref=&quot;sale.view_order_form&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于我们的模型派生自sale.model, 我们的视图也应该从sale.view_order_form视图派生而来, 这样我们可以增加一些自定义的字段. 开发模式下使用”Manage Views”查看这些信息.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;field name=&quot;arch&quot; type=&quot;xml&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;arch&lt;/em&gt;项是所有视图改变都需要的, 不需要知道为什么, 用吧.&lt;/p&gt;

&lt;p&gt;接下来就到了给新增的自定义字段指定显示位置了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;field name=&quot;client_order_ref&quot; position=&quot;after&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加字段到form上时, 应该明确地确定这个字段应该放在什么位置. 例如上面的那行代码, 告诉OpenERP框架首先找到&lt;em&gt;client_order_ref&lt;/em&gt;字段, 然后在它的后面(&lt;em&gt;position=”after”&lt;/em&gt;)显示增加的两个字段.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;client_order_ref&lt;/em&gt;字段怎么找到的? 只需要激活OE的开发者模式(OE的关于对话框中激活), 打开相应的view, 然后将鼠标悬停在字段的label上即可在tooltip上显示出来.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;field name=&quot;x_daterequired&quot;/&amp;gt;
&amp;lt;field name=&quot;x_rush&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这两句向form中添加我们新增的字段显示.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;安装模块&lt;/h2&gt;

&lt;p&gt;这个例子很简单, 仅仅把两个字段添加到了sales order form中, 这个模块目录中有四个文件:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;__init__.py&lt;/li&gt;
  &lt;li&gt;__openerp__.py&lt;/li&gt;
  &lt;li&gt;silkworm.py&lt;/li&gt;
  &lt;li&gt;silkworm_view.xml&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参数设定&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;OpenERP addons_path设定
首先./openerp-server -s, 在$HOME/下生成.openerp-serverrc文件, 修改其中的addons_path选项, 增加addons目录. 这里要注意, 多个路径之间用逗号分隔并且不能有空格.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;需要该用户启用了技术特性(设置-&amp;gt;用户-&amp;gt;编辑-&amp;gt;访问权限-&amp;gt;勾选”技术特性”).&lt;/p&gt;

&lt;p&gt;首先”设置-&amp;gt;更新模块列表”, 然后输入过滤关键字找到模块安装. 安装后打开一个sale order(销售订单), 可以看到在”客户关联单号(client_order_ref)”后增加了两个新的字段.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;注意: 安装模块时, 不要使用Modules菜单节中的Apps项, 该项仅显示OpenERP的app repository中的标准模块.
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://www.jeffzhang.cn/openerp/2014/05/04/OpenERP-DEV-Notes-%287%29.-Custom-Module-Development-1</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/05/04/OpenERP-DEV-Notes-(7).-Custom-Module-Development-1</guid>
                <pubDate>2014-05-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Dev Notes (x). Tutorial</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;1. 创建项目&lt;/h2&gt;

&lt;p&gt;1.1 PyCharm中新建一个名为&lt;em&gt;openacademy&lt;/em&gt;的项目;&lt;/p&gt;

&lt;p&gt;1.2 添加__init__.py文件, 文件内容:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
import openacademy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.3 添加__openerp__.py文件, 文件内容:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-

{
    &quot;name&quot; : &quot;OpenAcademy&quot;,
    &quot;version&quot; : &quot;1.0&quot;,
    &quot;author&quot; : &quot;OpenERP SA&quot;,
    &quot;category&quot; : &quot;Tools&quot;,
    &quot;depends&quot; : [&quot;mail&quot;],
    &quot;data&quot; : [
        &quot;openacademy_view.xml&quot;,
        &quot;openacademy_data.xml&quot;,
        &quot;report/module_report.xml&quot;,
        &quot;wizard/module_wizard.xml&quot;,
    ],
    &quot;demo&quot; : [
            &quot;openacademy_demo.xml&quot;
    ],
        &quot;installable&quot;: True,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.4 添加OpenERP源码&lt;/p&gt;

&lt;p&gt;“File”=&amp;gt;”Open Directory…“选择OpenERP源码目录, 拷贝openerp-serer.conf到根目录并配置, 在openerp根目录下的openerp-server上右键并选择”Run ‘openerp-server’“启动服务器(注意之前先启动PostgreSQL服务), 访问http://localhost:8069/, 确认成功.&lt;/p&gt;

&lt;p&gt;1.5&lt;/p&gt;
</description>
                <link>http://www.jeffzhang.cn/openerp/2014/04/22/OpenERP-DEV-Notes-%28x%29.-Tutorial</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/04/22/OpenERP-DEV-Notes-(x).-Tutorial</guid>
                <pubDate>2014-04-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Dev Notes (3). Objects Fields And Methods</title>
                <description>
&lt;h2 id=&quot;modules&quot;&gt;1.3 Modules&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;1.3.2 对象, 字段和方法&lt;/h3&gt;

&lt;h3 id=&quot;openerp-objects&quot;&gt;OpenERP Objects&lt;/h3&gt;

&lt;p&gt;OpenERP中, 所有数据资源通过objects来访问.&lt;/p&gt;

&lt;p&gt;注意, 每一类资源对应一个object, 而不是每个资源对应一个对象. 例如, res.partner管理所有的partner, 而不是一个partner对应一个res.partner. 用OO的话来说, 一个object是一个类而不是一个对象.&lt;/p&gt;

&lt;p&gt;这样, 对象的每个方法有一个”ids”参数, 用来确定这个方法应用到的资源.&lt;/p&gt;

&lt;p&gt;例如, 如果两个partner, id分别为1和5, 那么向他们发送email的方法”send_email”方法应该这样调用:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res_partner.send_email(..., [1,5], ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于开发者来说:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OpenERP的”objects”对应OO中的类&lt;/li&gt;
  &lt;li&gt;一个OpenERP的”resource”对应OO中的类的实例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个OpenERP的”resource”可以通过”browser”类方法(OpenERP的对象方法)转换为一个Python对象.&lt;/p&gt;

&lt;h3 id=&quot;orm&quot;&gt;ORM&lt;/h3&gt;

&lt;p&gt;OpenERP中, ORM为objects和PostgreSQL中的数据架起一座桥梁.&lt;/p&gt;

&lt;h3 id=&quot;openerp&quot;&gt;OpenERP对象属性&lt;/h3&gt;

&lt;h4 id=&quot;section-1&quot;&gt;对象介绍&lt;/h4&gt;

&lt;p&gt;为了定一个新的对象, 必须定义一个新的Python类并实例化它, 这个类必须派生自osv类(osv module中).&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;对象定义&lt;/h4&gt;

&lt;p&gt;使用一些预定义名称的域来定义对象, 其中两个是必须的(_name和_columns), 其他是可选的.&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;预定义域&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;_auto&lt;/strong&gt;: 确定是否根据对象自动创建PostgreSQL表. 例如, 当处理由PostgreSQL的视图产生的对象时, 将此域设置为False. 查看”从PostgreSQL视图生成报表”获得更多信息.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_columns(必需)&lt;/strong&gt;: 对象字段定义, 查看”字段”部分获取更多信息.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_constraints&lt;/strong&gt;: 对象约束, 查看”约束”部分获取更多信息.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_sql_constraints&lt;/strong&gt;: 对象的SQL约束, 查看”SQL约束”部分获取更多信息.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_default&lt;/strong&gt;: 对象一些字段的默认值.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_inherit&lt;/strong&gt;: 当前对象派生自的osv对象的名字. 查看”对象继承”部分获取更多信息.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_inherits&lt;/strong&gt;: 当前对象派生自的osv对象列表, 这个列表必需是一个下列形式的python字典: {‘name_of_the_parent_object’: ‘name_of_the_field’, …}, 默认值为{}. 查看”对象继承”部分获取更多信息.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_log_access&lt;/strong&gt;: 确定资源写操作是否记入日志. 如果为true, 四个字段将会添加到表中: create_uid, create_date, write_uid, write_date. 这些字段用于保存记录的创建人id和时间, 以及修改人id和时间. 这些数据可以通过perm_read方法获得.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_name(必需)&lt;/strong&gt;: 对象名, 默认值: None.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_order&lt;/strong&gt;: 用于排序检索或读方法结果的fields. 默认值: ‘id’. 示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_order = &quot;name&quot;
_order = &quot;date_order desc&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;_rec_name&lt;/strong&gt;: 资源名所保存的字段名, 默认值为:’name’. 注意, 默认情况下”name_get”方法简单地返回这个字段的内容.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_sequence&lt;/strong&gt;: 管理对象ids的SQL序列名称, 默认值: None.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_sql&lt;/strong&gt;: 对象创建时执行的sql代码, 只有_auto设置为True有效. 当表创建后这段代码将被执行.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_table&lt;/strong&gt;: SQL表名, 默认值为_name域的值(用下划线’_‘替换_name中的’.’)&lt;/p&gt;

&lt;h4 id=&quot;inherit&quot;&gt;对象继承 - _inherit&lt;/h4&gt;

&lt;p&gt;添加/修改对象的字段, 用继承挺好.&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;扩展一个对象&lt;/h4&gt;

&lt;p&gt;两种方式, 每种都创建一类新的数据, 新的数据保持了原有的字段和行为并且具有了新的字段和行为, 但是这两种方法的后续编程方法有很大的不同.&lt;/p&gt;

&lt;p&gt;示例1创建一个新的子类”custom_material”, 它可以被处理”network.material”的view或tree看到或使用, 示例2与此不同.&lt;/p&gt;

&lt;p&gt;示例1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class custom_material(osv.osv):
    _name = ’network.material’
    _inherit = ’network.material’
    _columns = {
        ’manuf_warranty’: fields.boolean(’Manufacturer warranty?’),
    }
    _defaults = {
        ’manuf_warranty’: lambda *a: False,
    }

custom_material()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例1注意: _name == _inherit&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;示例1中, ‘curtom_material’相比与’network.material’新增了一个字段’manuf_warranty’. 新的类实例能够被能处理”network.material”的view或tree识别.&lt;/p&gt;

&lt;p&gt;这种继承在OO中被称为”类继承”, 子类继承了父类的数据(fields)和行为(functions).&lt;/p&gt;

&lt;p&gt;示例2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class other_material(osv.osv):
    _name = ’other.material’
    _inherit = ’network.material’
    _columns = {
            ’manuf_warranty’: fields.boolean(’Manufacturer warranty?’),
    }
    _defaults = {
        ’manuf_warranty’: lambda *a: False,
    }

other_material()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例2注意: _name != _inherit&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;示例2中, ‘other_material’保留所有’network.material’的字段, 并且增加了一个新的字段’manuf_warranty’. 所有这些字段是’other.material’表的一部分. 这个类的新实例不能被’network.material’表上的view和tree识别.&lt;/p&gt;

&lt;p&gt;这种继承被称为”原型继承”(Javascript就是这种继承), 因为新创建的子类从父类(原型prototype)拷贝了所有字段. 子类继承了其父类的所有数据和行为.&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;委托继承&lt;/h4&gt;

&lt;p&gt;语法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class tiny_object(osv.osv)
    _name = ’tiny.object’
    _table = ’tiny_object’
    _inherits = {
        ’tiny.object_a’: ’object_a_id’,
        ’tiny.object_b’: ’object_b_id’,
        ... ,
        ’tiny.object_n’: ’object_n_id’
    }
    (...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象tiny_object从n个对象(tiny.object_a, tiny.object_b,…,tiny.object_n)继承了所有的列以及所有的方法.&lt;/p&gt;

&lt;p&gt;为了从多个表继承, 每个被继承的对象在tiny_object表中增加一列, 该列保存一个外键. object_a_id, object_b_id,…,object_n_id是类型字符串, 并且确定了外键列的标题, 外键列保存从tiny.object_a, tiny.object_b,…,tiny.object_n而来的外键.&lt;/p&gt;

&lt;p&gt;这种继承机制被称为实例继承或值继承, 一个资源(实例)具有其parents的VALUES.&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;字段介绍&lt;/h4&gt;

&lt;p&gt;对象包含不同类型的字段, 可以分为三类: 简单类型, 关系类型和函数字段. 简单类型是整形, 浮点, boolean, 字符串等; 关系类型用于表示对象间的关系, 例如one2one, one2many, many2one等. 函数字段是特殊的字段, 因为它们并不保存在数据库中, 而是在使用时由其他字段实时计算得到他们的值.&lt;/p&gt;

&lt;p&gt;OpenERP的类初始化代码(__init__()):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def __init__(self, string=’unknown’, required=False, readonly=False,
             domain=None, context=&quot;&quot;, states=None, priority=0, change_default=False, size=None,
             ondelete=&quot;set null&quot;, translate=False, select=False, **args) :
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可选参数列表如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;change_default: 这个字段的值决定用户是否可以为其他字段的默认值. 默认值需要定义在ir.values表中.&lt;/li&gt;
  &lt;li&gt;help: 一段说明字段如何使用的文本描述, 当鼠标滑过字段上方时, 这些文字将在tooltip显示出来.&lt;/li&gt;
  &lt;li&gt;ondelete: 删除时如何处理相关的记录, 允许的值为: restrict, no action, cascade, set null, set default.&lt;/li&gt;
  &lt;li&gt;priority: Not used?&lt;/li&gt;
  &lt;li&gt;readonly: 该字段是否只读, 也即不能编辑.&lt;/li&gt;
  &lt;li&gt;required: 是否必须.&lt;/li&gt;
  &lt;li&gt;size: number characters or digits.&lt;/li&gt;
  &lt;li&gt;states:&lt;/li&gt;
  &lt;li&gt;string: 显示在标签或列头的文本. 如果包含非ASCII字符, 那么必须用python的unicode字符串. 例如: fields.boolean(u’测试’).&lt;/li&gt;
  &lt;li&gt;translate: 布尔值, 指示该字段是否翻译.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他一些可选的参数:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;context:&lt;/li&gt;
  &lt;li&gt;domain:&lt;/li&gt;
  &lt;li&gt;invisible: 在forms上隐藏字段值, 例如密码.&lt;/li&gt;
  &lt;li&gt;on_change:&lt;/li&gt;
  &lt;li&gt;relation:&lt;/li&gt;
  &lt;li&gt;select:&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;字段类型&lt;/h3&gt;

&lt;h4 id=&quot;section-8&quot;&gt;基本类型&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;boolean&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.boolean(’Field Name’ [, Optional Parameters]),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;integer&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.integer(’Field Name’ [, Optional Parameters]),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;float&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.float(’Field Name’ [, Optional Parameters]),
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意: 可选参数digits定义数字的精度(包括小数点前后总有效位数)和小数位数(小数点后位数). 如果此参数没有定义, 此字段是一个双精度浮点数. 警告: 浮点数字可能是不准确的, 会导致误差, 所以对于金额之类的精确数字, 应该定义参数.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;char&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.char(
        ’Field Name’,
        size=n [,
        Optional Parameters]), # where ’’n’’ is an integer.

示例: ’city’ : fields.char(’City Name’, size=30, required=True),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;text&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.text(’Field Name’ [, Optional Parameters]),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;date&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.date(’Field Name’ [, Optional Parameters]),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;datetime&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.datetime(’Field Name’ [, Optional Parameters]),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;binary&lt;/strong&gt;: 二进制链&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;selection&lt;/strong&gt;: 一个允许用户在一些预定义值中选择的字段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.selection(((’n’,’Unconfirmed’), (’c’,’Confirmed’)),
               ’Field Name’ [, Optional Parameters]),
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意: 参数格式为: 字符串元组的元组
((’key_or_value’, ’string_to_display’), … )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意: 也可以指定一个用来返回元组的函数, 例如&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def _get_selection(self, cursor, user_id, context=None): return (
       (’choice1’, ’This is the choice 1’),
       (’choice2’, ’This is the choice 2’))
_columns = {
   ’sel’ : fields.selection(
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;: 在selection使用many2one的关系字段, 字段定义中添加以下内容:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...,
’my_field’: fields.many2one(
        ’mymodule.relation.model’,
        ’Title’,
        selection=_sel_func),
...,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中_sel_func定义为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def _sel_func(self, cr, uid, context=None):
    obj = self.pool.get(’mymodule.relation.model’)
    ids = obj.search(cr, uid, [])
    res = obj.read(cr, uid, ids, [’name’, ’id’], context) res = [(r[’id’], r[’name’]) for r in res]
    return res
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;关系类型&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;one2one&lt;/strong&gt;: 表示两个对象间1对一的关系, 现在已经不再使用, 用many2one代替之.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.one2one(’other.object.name’, ’Field Name’)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;many2one&lt;/strong&gt;: 对象通过这个字段关联父对象, 例如, 员工与所属部门是多对一关系, 多个员工属于一个部门.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.many2one(
        ’other.object.name’,
        ’Field Name’,
        optional parameters)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可选参数:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ondelete: 当字段对应的资源被删时做什么, 可以选择的操作: 预定义值(cascade, set null, restrict, no action set default)和默认值(set null)&lt;/li&gt;
  &lt;li&gt;required: 是否必填&lt;/li&gt;
  &lt;li&gt;readonly: 是否只读&lt;/li&gt;
  &lt;li&gt;select: 在外键字段创建一个索引&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;’commercial’: fields.many2one(
        ’res.users’,
        ’Commercial’,
        ondelete=’cascade’),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;one2many&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.one2many(
        ’other.object.name’,
        ’Field relation id’,
        ’Fieldname’,
        optional parameter)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可选参数:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;invisible:&lt;/li&gt;
  &lt;li&gt;states:&lt;/li&gt;
  &lt;li&gt;readonly:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;’address’: fields.one2many(
        ’res.partner.address’,
        ’partner_id’,
        ’Contacts’),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;many2many&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fields.many2many(’other.object.name’,
                 ’relation object’,
                 ’actual.object.id’,
                 ’other.object.id’,
                 ’Field Name’)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;other.object.name是属于这个关联关系的另一个对象&lt;/li&gt;
  &lt;li&gt;relation object是关联表&lt;/li&gt;
  &lt;li&gt;actual.object.id和other.object.id是关联表中的字段名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;’category_ids’:
   fields.many2many(
    ’res.partner.category’,
    ’res_partner_category_rel’,
    ’partner_id’,
    ’category_id’,
    ’Categories’),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了双向访问(也即在另一个对象中创建一个字段):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class other_object_name2(osv.osv):
    _inherit = ’other.object.name’
    _columns = {
        ’other_fields’: fields.many2many(
            ’actual.object.name’,
            ’relation object’,
            ’actual.object.id’,
            ’other.object.id’,
            ’Other Field Name’),
other_object_name2()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class res_partner_category2(osv.osv):
    _inherit = ’res.partner.category’
    _columns = {
        ’partner_ids’: fields.many2many(
            ’res.partner’,
            ’res_partner_category_rel’,
            ’category_id’,
            ’partner_id’,
            ’Partners’),
    }
res_partner_category2()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;related&lt;/strong&gt;: 有时需要引用关系的关系. 例如, 假设有城市-&amp;gt;省-&amp;gt;国家的关系, 如果需要从城市引用国家, 那么就需要在城市对象上定义一个字段, 如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;’country_id’: fields.related(
    ’state_id’,
    ’country_id’,
    type=&quot;many2one&quot;,
    relation=&quot;res.country&quot;,
    string=&quot;Country&quot;,
    store=False)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一组参数是字段的引用链, 引用链的最后是希望引用的字段.&lt;/li&gt;
  &lt;li&gt;type是希望引用的字段的类型&lt;/li&gt;
  &lt;li&gt;如果希望字段仍然是某种引用, 那就使用relation. relation用于查询表中引用.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-10&quot;&gt;函数字段&lt;/h3&gt;

</description>
                <link>http://www.jeffzhang.cn/openerp/2014/04/22/OpenERP-DEV-Notes-%283%29.-Objects-Fields-and-Methods</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/04/22/OpenERP-DEV-Notes-(3).-Objects-Fields-and-Methods</guid>
                <pubDate>2014-04-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Dev Notes (2). Modules Structure</title>
                <description>
&lt;h2 id=&quot;modules&quot;&gt;1.3 Modules&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;1.3.1 模块结构&lt;/h3&gt;

&lt;p&gt;一个模块包含以下要素:&lt;/p&gt;

&lt;p&gt;业务对象: 定义为派生自osv.Model的Python类, 这些资源的持久化由OpenERP的ORM管理.&lt;/p&gt;

&lt;p&gt;数据: 保存元数据(视图和工作流定义), 配置数据(模块参数)和demo数据(可选但推荐测试用)的XML/CSV文件.&lt;/p&gt;

&lt;p&gt;报表: RML(XML 格式)文件. HTML/MAKO或OpenOffice报表模板, 可以与任意类型的业务数据合并, 并产生HTML, ODT或PDF报表.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh4.googleusercontent.com/-TUpcoLCQCiw/Uz0bz5OzNiI/AAAAAAAAATg/cei0vdpreug/s800/OE_module_composition.png&quot; alt=&quot;OE Module composition&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例如, 创建一个’OpenAcademy’模块示例, 需要下列步骤:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在source/addons目录下创建一个&lt;em&gt;openacademy&lt;/em&gt;子目录;&lt;/li&gt;
  &lt;li&gt;创建一个模块import文件__init__.py文件;&lt;/li&gt;
  &lt;li&gt;创建一个模块清单(manifest)文件__openerp__.py;&lt;/li&gt;
  &lt;li&gt;创建包含对象的Python文件s;&lt;/li&gt;
  &lt;li&gt;创建xml文件定义模块数据, 例如视图, 菜单项或demo数据;&lt;/li&gt;
  &lt;li&gt;选择性地创建报表和工作流定义文件;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;initpy&quot;&gt;__init__.py&lt;/h3&gt;

&lt;p&gt;Python的import文件, OpenERP模块也是一个标准的Python模块, 这个文件导入该模块所有其他的python文件和子模块. 例如, 如果一个模块仅包含一个名为openacademy.py的文件, __init__.py文件的内容应该是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import openacademy
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;openerppy&quot;&gt;__openerp__.py&lt;/h3&gt;

&lt;p&gt;每个模块目录下必须有这个文件, 这个文件中, 用python的字典确定:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务器初始化时需要解析的XML文件;&lt;/li&gt;
  &lt;li&gt;该模块的依赖项;&lt;/li&gt;
  &lt;li&gt;定义额外的元数据.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个文件包含的字典中需要有这些key:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;name&lt;/em&gt;&lt;/strong&gt;:             The name of the module in English.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;version&lt;/em&gt;&lt;/strong&gt;:          The version of the module.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;summary&lt;/em&gt;&lt;/strong&gt;:          Short description or keywords&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;description&lt;/em&gt;&lt;/strong&gt;:      The module description (text).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;category&lt;/em&gt;&lt;/strong&gt;:         The categrory of the module&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;author&lt;/em&gt;&lt;/strong&gt;:           The author of the module.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;website&lt;/em&gt;&lt;/strong&gt;:          URL of the website of the module.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;license&lt;/em&gt;&lt;/strong&gt;:          The license of the module (default: AGPL-3).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;depends&lt;/em&gt;&lt;/strong&gt;:          List of modules on which this module depends beside base.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;data&lt;/em&gt;&lt;/strong&gt;:             List of .xml files to load when the module is installed or updated.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;demo&lt;/em&gt;&lt;/strong&gt;:             List of additional .xml files to load when the module is installed or updated and demo flag is active.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;installable&lt;/em&gt;&lt;/strong&gt;:      True or False. Determines whether the module is installable or not.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;auto_install&lt;/em&gt;&lt;/strong&gt;:     True or False (default: False). If set to ‘‘True‘‘, the module is a link module. It will be installed as soon as all its dependencies are installed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如, &lt;strong&gt;openacademy&lt;/strong&gt;模块的__openerp__.py中的字典如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;name&quot; : &quot;OpenAcademy&quot;,
    &quot;version&quot; : &quot;1.0&quot;,
    &quot;author&quot; : &quot;OpenERP SA&quot;,
    &quot;category&quot; : &quot;Tools&quot;,
    &quot;depends&quot; : [&quot;mail&quot;],
    &quot;data&quot; : [
        &quot;openacademy_view.xml&quot;,
        &quot;openacademy_data.xml&quot;,
        &quot;report/module_report.xml&quot;,
        &quot;wizard/module_wizard.xml&quot;,
    ],
    &quot;demo&quot; : [
            &quot;openacademy_demo.xml&quot;
    ],
        &quot;installable&quot;: True,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;objects&quot;&gt;对象(Objects)&lt;/h3&gt;

&lt;p&gt;OpenERP中, 所有的资源都是对象(Objects), 例如: 发票, partners等. 元数据也是对象: 菜单(menus), 动作(actions), 报表(reports)……对象命名是分层的, 例如:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;account.transfer: a money transfer&lt;/li&gt;
  &lt;li&gt;account.invoice: 一个发票&lt;/li&gt;
  &lt;li&gt;account.invoice.line: 一个发票行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般情况下, 第一个单词是模块名(account, stock, sale), 这些对象定义为osv.Model的派生类.&lt;/p&gt;

&lt;p&gt;可以直接使用SQL语句来操作PostgreSQL数据库, 但是这样做事危险的, 可能会导致数据不一致等等错误.&lt;/p&gt;

&lt;h3 id=&quot;xml&quot;&gt;XML文件&lt;/h3&gt;

&lt;p&gt;模块目录下的xml文件用于模块安装/更新时初始化/更新数据库, 例如:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义初始和示例数据;&lt;/li&gt;
  &lt;li&gt;定义视图;&lt;/li&gt;
  &lt;li&gt;定义报表;&lt;/li&gt;
  &lt;li&gt;定义工作流;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于xml文件结构的更多细节见&lt;strong&gt;&lt;em&gt;xml-serialization section TODO:换成文章链接&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;OpenERP对象可以通过使用该对象相应的XML文件插入到相应的PostgreSQL表中, 一个OpenERP XML文件的一般结构如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;openerp&amp;gt;
    &amp;lt;data&amp;gt;
        &amp;lt;record model=&quot;model.name_1&quot; id=&quot;id_name_1&quot;&amp;gt;
            &amp;lt;field name=&quot;field1&quot;&amp;gt; &quot;field1 content&quot; &amp;lt;/field&amp;gt;
            &amp;lt;field name=&quot;field2&quot;&amp;gt; &quot;field2 content&quot; &amp;lt;/field&amp;gt;
            (...)
        &amp;lt;/record&amp;gt;
        &amp;lt;record model=&quot;model.name_2&quot; id=&quot;id_name_2&quot;&amp;gt;
            (...)
        &amp;lt;/record&amp;gt;
        (...)
    &amp;lt;/data&amp;gt;
&amp;lt;/openerp&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;record-tag&quot;&gt;Record Tag&lt;/h3&gt;

&lt;p&gt;Record标记描述新数据, 它有一个必需的属性model, 它的值应该是一个将执行插入数据的对象名; record标记还可以有一个可选的id属性, 如果这个属性赋值了, 那么这个id值可以在这个文件的后面作为这个资源的引用标示符(ID)来使用.&lt;/p&gt;

&lt;p&gt;一个record标记可以包含多个field标记, 指出这些字段的值, 如果没有给出字段值则使用默认值.&lt;/p&gt;

&lt;h3 id=&quot;the-record-field-tag&quot;&gt;The Record Field tag&lt;/h3&gt;

&lt;p&gt;field标记的属性如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;name: 必需的, 字段名&lt;/li&gt;
  &lt;li&gt;eval: 可选的, 一个python表达式, 通过它计算值&lt;/li&gt;
  &lt;li&gt;ref: 对本文件中出现过的id的引用&lt;/li&gt;
  &lt;li&gt;model: 搜索时使用的模型&lt;/li&gt;
  &lt;li&gt;search: 一个查询&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;record model=&quot;ir.actions.report.xml&quot; id=&quot;l0&quot;&amp;gt;
    &amp;lt;field name=&quot;model&quot;&amp;gt;account.invoice&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;name&quot;&amp;gt;Invoices List&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;report_name&quot;&amp;gt;account.invoice.list&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;report_xsl&quot;&amp;gt;account/report/invoice.xsl&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;report_xml&quot;&amp;gt;account/report/invoice.xml&amp;lt;/field&amp;gt;
&amp;lt;/record&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;下面是一个OpenERP源码中的示例(base模块中的base_demo.xml)&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;record model=&quot;res.company&quot; id=&quot;main_company&quot;&amp;gt;
    &amp;lt;field name=&quot;name&quot;&amp;gt;Tiny sprl&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;partner_id&quot; ref=&quot;main_partner&quot;/&amp;gt;
    &amp;lt;field name=&quot;currency_id&quot; ref=&quot;EUR&quot;/&amp;gt;
&amp;lt;/record&amp;gt;
&amp;lt;record model=&quot;res.users&quot; id=&quot;user_admin&quot;&amp;gt;
    &amp;lt;field name=&quot;login&quot;&amp;gt;admin&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;password&quot;&amp;gt;admin&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;name&quot;&amp;gt;Administrator&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;signature&quot;&amp;gt;Administrator&amp;lt;/field&amp;gt;
    &amp;lt;field name=&quot;action_id&quot; ref=&quot;action_menu_admin&quot;/&amp;gt;
    &amp;lt;field name=&quot;menu_id&quot; ref=&quot;action_menu_admin&quot;/&amp;gt;
    &amp;lt;field name=&quot;address_id&quot; ref=&quot;main_address&quot;/&amp;gt;
    &amp;lt;field name=&quot;groups_id&quot; eval=&quot;[(6,0,[group_admin])]&quot;/&amp;gt;
    &amp;lt;field name=&quot;company_id&quot; ref=&quot;main_company&quot;/&amp;gt;
&amp;lt;/record&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后一条记录定义了admin用户:&lt;/p&gt;

&lt;p&gt;1 login, password等字段简单地直接给出值&lt;/p&gt;

&lt;p&gt;2 ref属性允许在记录间建立联系:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;field name=&quot;company_id&quot; ref=&quot;main_company&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;company_id&lt;/strong&gt;字段是一个从user对象到公司对象的many-to-one关系, &lt;strong&gt;main_company&lt;/strong&gt;是关联的ID.&lt;/p&gt;

&lt;p&gt;3 eval属性允许在xml中放置一些python代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;field name=&quot;groups_id&quot; eval=&quot;[(6,0,[group_admin])]&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的groups_id字段是一个many2many字段, “[(6,0,[group_admin])]”表示: 移除所有当前user的groups关联并使用一个[group_admin]列表作为新的groups关联, 这里group_admin也是另一个record的id.&lt;/p&gt;

&lt;p&gt;4 search属性可以在不知道xml中id的情况下, 通过搜索发现关联的记录. 可以给出一个特定的查询条件来查找记录. 查询条件是一个查询条件元组的列表.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;field name=&quot;partner_id&quot; search=&quot;[]&quot; model=&quot;res.partner&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上xml代码是一个demo数据中的典型例子: 因为不关心到底使用哪个partner, 所以搜索条件列表为空, 注意此时&lt;strong&gt;model&lt;/strong&gt;属性是必需的.&lt;/p&gt;

&lt;h3 id=&quot;function-tag&quot;&gt;Function tag&lt;/h3&gt;

&lt;p&gt;函数表几种可以包含其他函数标记, 属性如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;model: 必需, 涉及的model&lt;/li&gt;
  &lt;li&gt;name: 必填, 函数名&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;eval: 计算表达式
&lt;strong&gt;示例&lt;/strong&gt;:&lt;/p&gt;

    &lt;function model=&quot;ir.ui.menu&quot; name=&quot;search&quot; eval=&quot;[[(’name’,’=’,’Operations’)]]&quot; /&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;views&quot;&gt;Views&lt;/h3&gt;

&lt;p&gt;Views是一种在客户端展现对象的方式, Views指出如何在屏幕上摆放从对象获得的数据. Views有两类:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;form views&lt;/li&gt;
  &lt;li&gt;tree views&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lists是一种简单的tree views的特例.&lt;/p&gt;

&lt;p&gt;一个对象可能有多种views, 第一个定义的一类view(tree, form等)将作为这类的默认view. 这样就可以有一个默认的tree view(作为one2many的view)和一个特定用于显示多些或少些信息的view, 后者在双击菜单项是显示. 例如, 根据不同产品, products有多个views.&lt;/p&gt;

&lt;p&gt;views用XML描述.&lt;/p&gt;

&lt;p&gt;如果某个对象没有定义view, 那么这个对象可以产生一个默认的基本view来显示自己, 这样可以减小工作量.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;使用示例&lt;/h3&gt;

&lt;p&gt;打开一个发票时的操作链:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个action请求打开the invoice, 给定了相应的对象数据(account.invoice), 视图以及domain(例如仅显示为支付的invoices)&lt;/li&gt;
  &lt;li&gt;客户端询问(通过XML-RPC)服务器这个invoice对象定义了哪些views, 以及哪些数据必须显示&lt;/li&gt;
  &lt;li&gt;客户端显示相应的view&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;to-develop-new-objects&quot;&gt;To develop new objects&lt;/h3&gt;

&lt;p&gt;设计新的对象的最小工作: 创建对象, 可选地创建相应的views. PostgreSQL表不需要手动操作, 因为对象可以自动创建它们(或调整已存在的表).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reports&lt;/strong&gt;: OpenERP使用一个强力且灵活的报表系统, 可以生成PDF或HTML格式的报表. 更多报表信息参见&lt;strong&gt;TODO:修改这里为 报表章节链接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Workflow&lt;/strong&gt;: 使用对象和views可以方便地定义新的forms, lists/trees, 及它们之间的交互, 但是还需要能够定义这些对象动态特性.&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了确认一个销售订单, 必须产生相对应的发票&lt;/li&gt;
  &lt;li&gt;特定情况下, 支付发票后应该启动发货&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;工作流用图的形式描述这些交互, 对象可能关联到一个或多个工作流, 但工作流不是必需的, 有些对象没有相关的工作流.&lt;/p&gt;

&lt;p&gt;下面是sale orders相关的工作流例子:&lt;/p&gt;

&lt;p&gt;在图中, 节点表示要进行的actions, 例如:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个发票&lt;/li&gt;
  &lt;li&gt;取消销售单&lt;/li&gt;
  &lt;li&gt;生成发运单&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;箭头表示条件, 例如:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;等待订单验证&lt;/li&gt;
  &lt;li&gt;支付发票&lt;/li&gt;
  &lt;li&gt;点击取消按钮&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;方块节点表示其他工作流, 例如:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发票&lt;/li&gt;
  &lt;li&gt;发运&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;i18n&lt;/strong&gt;: 每个模块都有自己的i18n文件夹. 另外, OpenERP还可以用.po文件来导入/导出. 已安装的翻译文件在安装或升级模块时自动加载.&lt;/p&gt;

</description>
                <link>http://www.jeffzhang.cn/openerp/2014/04/03/OpenERP-DEV-Notes-%282%29.-Modules-structure</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/04/03/OpenERP-DEV-Notes-(2).-Modules-structure</guid>
                <pubDate>2014-04-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Dev Notes (1). Getting Started</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;1.1 起步&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.1.1 从源码安装&lt;/h3&gt;

&lt;p&gt;安装各种依赖包, 然后bzr安装, 具体见&lt;em&gt;OpenERP Technical Memento&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1.2 命令行参数&lt;/h3&gt;

&lt;p&gt;./openerp-server –help&lt;/p&gt;

&lt;h3 id=&quot;configuration&quot;&gt;1.1.3 Configuration&lt;/h3&gt;

&lt;p&gt;两个配置文件: &lt;em&gt;~/.openerprc&lt;/em&gt;; &lt;em&gt;~/.openerp_serverrc&lt;/em&gt;. 如果没有发现, 说明服务器和客户端用默认配置启动. 服务端配置文件可以使用&lt;em&gt;./openerp-server -s&lt;/em&gt;或&lt;em&gt;./openerp-server –save&lt;/em&gt;创建.&lt;/p&gt;

&lt;p&gt;还可以通过命令行参数指定配置文件: &lt;em&gt;-c CONFIG&lt;/em&gt;; &lt;em&gt;-config=CONFIG&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;addons&quot;&gt;配置addons位置&lt;/h4&gt;

&lt;p&gt;addons默认在&lt;em&gt;server/bin/addons&lt;/em&gt;, 源码安装的在&lt;em&gt;openerp/addons&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在addons目录创建连接;&lt;/li&gt;
  &lt;li&gt;启动server时用命令行参数设定: &lt;em&gt;–addons-path=ADDONS_PATH&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;start-up&quot;&gt;1.1.4 Start-up脚本&lt;/h3&gt;

&lt;h2 id=&quot;section-3&quot;&gt;1.2 架构&lt;/h2&gt;

&lt;h3 id=&quot;openerp&quot;&gt;1.2.1 多端三层架构的OpenERP&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;数据库层用于数据存储&lt;/li&gt;
  &lt;li&gt;应用层处理各种功能性工作&lt;/li&gt;
  &lt;li&gt;表示层提供用户接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OpenERP系统由三部分组成:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;包含所有OpenERP数据库的PostgreSQL数据库服务器. 数据库中保存了所有的应用数据, 以及很多OpenERP系统配置数据. 可以部署为集群数据库;&lt;/li&gt;
  &lt;li&gt;OpenERP服务器, 包括所有的企业逻辑并确保OpenERP runs optimally. OEM引擎用于与PostgreSQL数据库交互, Web层用于服务器与web浏览器之间交互. 可以部署多服务器, 例如使用负载平衡的多服务器互联;&lt;/li&gt;
  &lt;li&gt;client是一个javascript应用, 运行在web浏览器中.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Server - ORM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ORM层是OpenERP的一个非常突出的特性. 在PostgreSQL之上提供了必须及额外的功能. 数据模型使用Python描述, OpenERP使用ORM来创建下层的数据库表. RDBMS的特性, 例如唯一性约束, 有效的查询等, 都可以通过Python灵活地完成, 例如Python编写的约束可以添加到任意的模型上.&lt;/p&gt;

&lt;p&gt;利用ORM可以获得:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;强力的有效性检查从而保证了一致性;&lt;/li&gt;
  &lt;li&gt;对象级别的接口, 从而能够更有效地设计和实现模块;&lt;/li&gt;
  &lt;li&gt;各个用户和组的低级别上的安全保证;&lt;/li&gt;
  &lt;li&gt;资源组的复杂动作;&lt;/li&gt;
  &lt;li&gt;提供继承服务从而使新的资源能够更好地建模.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Server - Web&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在Web层是一个基于&lt;em&gt;werkzeug&lt;/em&gt;的WSGI兼容应用.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Modules&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;OpenERP服务器是核心, 对于企业来说, OpenERP的价值在于它的各个功能模块. 模块用来实现各种商务需求.&lt;/p&gt;

&lt;h3 id=&quot;mvc&quot;&gt;1.2.2 MVC架构&lt;/h3&gt;

&lt;p&gt;略…&lt;/p&gt;

&lt;h3 id=&quot;wsgi&quot;&gt;1.2.3 网络通信及WSGI&lt;/h3&gt;

&lt;p&gt;OpenERP是一个HTTP的web服务, 也可以部署为一个WSGI兼容应用.&lt;/p&gt;

&lt;p&gt;WSGI是Python生态系统中用于编写HTTP服务, 应用及中间件的解决方案标准.&lt;/p&gt;

</description>
                <link>http://www.jeffzhang.cn/openerp/2014/04/03/OpenERP-DEV-Notes-%281%29.-Getting-started</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/04/03/OpenERP-DEV-Notes-(1).-Getting-started</guid>
                <pubDate>2014-04-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Dev Notes (0). Pycharm Setting</title>
                <description>
&lt;h3 id=&quot;openerp&quot;&gt;导入OpenERP&lt;/h3&gt;
&lt;p&gt;创建一个空的工程作为开发OE模块使用的工程, 然后菜单”File”=&amp;gt;”Open Directory…“选择解压后的OpenERP目录, 目录结构如下图所示.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh5.googleusercontent.com/-SuINzxaUs20/Uzon9hnAMwI/AAAAAAAAASE/2ygcEVRN5mg/s800/oe_tree.png&quot; alt=&quot;OE Tree&quot; title=&quot;OE Tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在PyCharm中展开工程, 将install子目录下的”openerp-server.conf”拷贝到新加入的openerp根目录下, 并打开进行相应的修改.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;启动运行&lt;/h3&gt;
&lt;p&gt;在工程目录树根上找到”openerp-server”, 右键选择”Run ‘openerp-server’“启动服务器, 如果弹出错误, 可能是PostgreSQL没有启动或依赖的Python模块没有安装.&lt;/p&gt;

&lt;h3 id=&quot;python&quot;&gt;调试Python&lt;/h3&gt;
&lt;p&gt;在工程目录树根上找到”openerp-server”, 右键选择”Debug ‘openerp-server’“以调试模式启动服务器. 如果设置了断点, 就会在运行到断点处停下来.
注意Run和Debug前一定要确定只有一个OE服务器实例启动.&lt;/p&gt;

&lt;h3 id=&quot;javascript&quot;&gt;调试JavaScript&lt;/h3&gt;
&lt;p&gt;PyCharm里选择”Edit Configurations…”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-3st6TTwlwrs/UzowxGPghnI/AAAAAAAAATI/-WI5KCYOs6Y/s800/oe_debug_js_1.png&quot; alt=&quot;Debug JavaScript 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后在打开的窗口中选择”+”增加一个JavaScript的Debug设置.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-V9UEgj2xfeE/UzowxBmEH_I/AAAAAAAAATI/YfsVMWMudyg/s800/oe_debug_js_2.png&quot; alt=&quot;Debug JavaScript 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后按下图中设定.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh4.googleusercontent.com/-J8tF6m38H3A/UzowxEvpZNI/AAAAAAAAATI/qCB8pmaXH9Y/s800/oe_debug_js_3.png&quot; alt=&quot;Debug JavaScript 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设定好这些后, 启动openerp-server(Run或Debug均可), 然后选择js debug启动debug.  提示安装Chrome的JetBrains IDE Support支持插件, 安装之. 安装后的Chrome打开OE后如下图所示.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-hgR7chEljWs/UzowzMYMBGI/AAAAAAAAATI/xxQxga7dypY/s800/oe_debug_js_4.png&quot; alt=&quot;Debug JavaScript 4&quot; /&gt;&lt;/p&gt;

</description>
                <link>http://www.jeffzhang.cn/openerp/2014/04/01/OpenERP-DEV-Notes-%280%29.-PyCharm-Setting</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/04/01/OpenERP-DEV-Notes-(0).-PyCharm-Setting</guid>
                <pubDate>2014-04-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Notes(5). Purchasing With Openerp</title>
                <description>
&lt;p&gt;购买订单(PO)&lt;/p&gt;

&lt;p&gt;在CRM中增加供应商及其商品, 然后开始一个购买过程&lt;/p&gt;

</description>
                <link>http://www.jeffzhang.cn/openerp/2014/03/21/OpenERP-Notes%285%29.-Purchasing-with-OpenERP</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/03/21/OpenERP-Notes(5).-Purchasing-with-OpenERP</guid>
                <pubDate>2014-03-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Notes(4). Crm In Openerp</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;管理客户体验, 提高客户忠诚度.&lt;/li&gt;
  &lt;li&gt;把客户当成人看, 而不是一些数据, 客户会以他们的忠诚作为回报.&lt;/li&gt;
  &lt;li&gt;根据具体公司的核心目标和任务来构建CRM系统, 一个好的CRM系统不应当仅仅是管理销售过程, 而应该管理包括售前售后的完整用户体验.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;crm&quot;&gt;安装CRM应用&lt;/h2&gt;

&lt;h2 id=&quot;sales-representativeaccount-manager&quot;&gt;分配销售代表(sales representative)或客户经理(account manager)&lt;/h2&gt;

&lt;p&gt;类似于其他的CRM系统, 销售代表和客户经理在OE的CRM中也是非常重要的角色. 首先创建一个用户作为销售人员, 在OE中, 销售代表也是一个OE的系统用户.&lt;/p&gt;

&lt;p&gt;首先设置=&amp;gt;用户=&amp;gt;创建, 创建一个虚构的销售人员, 李销售(login:saleslee).&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;销售用户的设定&lt;/h3&gt;
&lt;p&gt;注意访问权限页面, 将李销售设置销售权限为”经理(Manager)”, 人力资源为”雇员(Employee)”
每个应用权限可选以下三种:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;看自己的线索(User: Own Leads Only)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最具限制性的权限, 具有此权限的用户只能看到他自己的或被赋予他们的线索, 不能看到赋予其他销售人员的线索.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有线索(User: All Leads)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到系统中的所有线索.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;经理(Manager)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经理具有最高级别的访问权限, 具有经理权限的用户可以看到所有线索并且可以访问应用的配置, 这个级别的权限还允许用户访问统计报表.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;用户登录密码&lt;/h3&gt;

&lt;p&gt;默认情况下, 创建系统用户不需要设定用户密码. 因为默认方法将发送给用户一封Email, 通过该Email中提供的信息用户可以自己设定自己的密码. 如果没有配置Email服务器, 可以在&lt;em&gt;保存用户后&lt;/em&gt;, 点击页面顶端的”更多”菜单, 从下拉选项中选择”Change Password”修改登录密码.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;为销售人员分配客户&lt;/h3&gt;

&lt;p&gt;“销售”=&amp;gt;选择”张三”, “编辑”=&amp;gt;”销售与采购”页面=&amp;gt;”销售员”设置为李销售, “销售团队”设置为销售部.&lt;/p&gt;

&lt;h2 id=&quot;leadsopportunities&quot;&gt;线索(leads)与商机(opportunities)&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;跟踪线索和商机&lt;/h3&gt;

&lt;p&gt;与商机相比, 线索被转化为真正的销售的可能性要小. 典型的线索例子是在某个会议期间收到很多名片, 这些名片都可以添加到你的线索中供以后跟踪利用. 典型的商机例子是与某人约见并详细地谈了一些关于为他们提供某种服务的事项.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;新建一个商机&lt;/h3&gt;

&lt;p&gt;在OE中, 新建一个商机就是定义一个新的潜在销售, 使用商机来收集一次销售相关的信息, 例如销售的范围和可能的结果等.&lt;/p&gt;

&lt;p&gt;选择”销售”=&amp;gt;”商机列表”=&amp;gt;”创建”, 打开创建商机界面.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 主题(Subject)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是创建商机时仅有的必填项.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 预期收益(Expected revenue and percentage)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3 客户&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果是从客户窗口创建机会, 那么这个字段会自动填写, 否则, 选一个吧.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4 下一动作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于这个商机, 下一个重要的动作是什么(文本提示)以及何时进行.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5 预期结束和优先级(Expected Closing and Priority)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为关闭销售设定一个目标, 以及这个商机的优先级.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6 分类(Categories)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;OE允许设定多个分类.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7 线索页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;选择了客户后, 线索页自动填写了部分数据, 剩余的联系人信息须填写. 联系人部分的”职务(Function)”字段可以在出发事件时提供更具体一些的信息.&lt;/p&gt;

&lt;p&gt;“参考来自(Referred By)”是一个简单的文本字段, 这里的数据作为一个说明, 指出谁可能参考这个商机.&lt;/p&gt;

&lt;h3 id=&quot;kanban&quot;&gt;在kanban视图查看商机&lt;/h3&gt;

&lt;p&gt;“销售”=&amp;gt;”商机列表”, 可以看到kanban视图中新建的商机. 鼠标移动到标签上, 点击右上角的下来图标, 可以进行一些操作.&lt;/p&gt;

&lt;p&gt;可以通过拖动商机标签到不同的列, 表示对应的销售处于不同的阶段.&lt;/p&gt;

&lt;h3 id=&quot;oeopenchatter&quot;&gt;OE的OpenChatter功能&lt;/h3&gt;

&lt;p&gt;作为OE7中最大的功能增强, OpenChatter功能提供了类似社会网络形式的业务文档交流处理.&lt;/p&gt;

&lt;p&gt;OpenChatter功能几乎可以处理OE中的所有业务文档.&lt;/p&gt;

&lt;p&gt;点击顶部的状态, 将这个商机的状态改变为”建议(Proposition)”, 在窗口的下方日志部分, 可以看到这个操作的记录.&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;管理商机&lt;/h3&gt;

&lt;p&gt;这个建议完成后, 可以记录一些信息为以后检视这个商机提供帮助. 这些信息可以记录在商机的”内部备注(Internal Notes)”中, 也可以使用OpenChatter功能来记录.&lt;/p&gt;

&lt;p&gt;使用OpenChatter记录这些信息为备注能够为产生一个自动添加时间戳副本. 另外, OpenChatter还可以自动向团队成员的收件箱发送消息.&lt;/p&gt;

&lt;p&gt;点击商机下方的”记录一个笔记(Log a note)”将一个备注附加到这个商机上. 这样添加备注后不会给其他人发送消息. 使用”附加一个文件(Attach a File)”功能还可以为备注添加附件文档. 点击保存后, 这个备注将被保存并且变为文档的OpenChatter日志.&lt;/p&gt;

&lt;h3 id=&quot;following-a-business-document&quot;&gt;跟踪业务文档(Following a business document)&lt;/h3&gt;

&lt;p&gt;OE将社会网络的概念代入到业务交流中. 如果一个用户跟踪(Following)了一个文档, 当它更新时, 将会自动获得该文档的更新, 在OE收件箱中收到通知. 商机编辑界面右下方可以设置何时受到通知.可以通过”加入其他的”增加其他用户Following.&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;准备电话联系&lt;/h3&gt;

&lt;p&gt;商机到了建议阶段, 可以准备电话联系了. 在查看商机窗口中点击”计划/电话访问的记录”打开窗体. 如果已经打过电话, 现在仅仅想记录它, 选择”记录通话日志(Log a Call)”即可. 假设我们需要”安排通话(Schedule a Call)”, 选定安排通话后, 能够设定计划日期(Planned Date), 其他大部分信息就已经填写好了. 点击”计划的电话访问(Schedule Call)”按钮后, 这次电话访问被记录在了日历中, 并且会有一个日志项显示在这个商机文档中.&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;查看通话安排&lt;/h3&gt;

&lt;p&gt;选择”销售”=&amp;gt;”准备电话联系(Scheduled Calls)”可以看到通话安排的列表. 点击行上绿色的箭头标记相应的通话为”保留(held)”. 点击这条记录打开一个窗口.&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;销售谈判&lt;/h2&gt;

&lt;p&gt;打开商机并且编辑记录, 预期收益为3750.00和80%, 并设置为谈判阶段.&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;修改销售阶段&lt;/h3&gt;

&lt;p&gt;销售阶段, 也就是商机列表的列是可以自定义的, 以满足不同的需求. 在kanban视图, 点击左上角的”添加新列(Add a new column)”连接, 打开的窗体中需要填写阶段名称(Stage Name), 相关状态, 概率和类型字段. 相关状态字段当到达这个阶段时, 应该赋以哪个预定义的状态.&lt;/p&gt;

&lt;p&gt;这里有个bug? 新建了stage, 但是在商机阶段中看不到新建的stage, 也就是无法改变到新建的stage, 只能在商机列表的kanban视图, 拖动商机到新建的stage, 再打开商机, 就正常了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OE中的status和stage&lt;/strong&gt;: status的范围要大, stage更精细.&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;关闭销售&lt;/h2&gt;

&lt;p&gt;经过努力地工作, 终于赢得了这个商机, 现在可以将这个商机转变为报价(Quotation)了.&lt;/p&gt;

&lt;p&gt;点击商机窗体顶部的”转为报价单(Make Quotation)”按钮, 弹出转为报价单窗体. 选定”已赢得”并点击创建, 商机直接变成了一个报价单. 在”销售”=&amp;gt;”报价单”中可以看到这个报价单.&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;新建线索&lt;/h2&gt;

&lt;p&gt;OE中, 创建商机和客户之前可以先创建线索. 例如, 收到一个名片或从网站收到一条线索.&lt;/p&gt;

&lt;p&gt;创建线索并没有创建一个客户, 但是在线索创建窗体, 可以通过为”客户”字段填写值来将这个线索变为一个客户.&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;为不同的产品自定义销售团队&lt;/h2&gt;

&lt;p&gt;在产品很多的公司, 可能需要为不同的产品线创建不同的销售团队. 不同销售阶段的目的就是为了给用户最积极的用户体验.&lt;/p&gt;

&lt;p&gt;点击”销售”=&amp;gt;”销售团队”, 在创建销售团队时, 可以定义不同的阶段.&lt;/p&gt;

</description>
                <link>http://www.jeffzhang.cn/openerp/2014/03/18/OpenERP-Notes%284%29.-CRM-in-OpenERP</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/03/18/OpenERP-Notes(4).-CRM-in-OpenERP</guid>
                <pubDate>2014-03-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Notes(3). Starting Your First Company</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;首先查看业务需求, 决定需要哪些模块, 并创建一个OpenERP数据库并配置需要的公司信息.
然后看看如何创建, 查看信息, 完成一个SO流程.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;模块化的实现&lt;/h3&gt;
&lt;p&gt;初次安装完成OpenERP后, 仅有一个基本的消息系统, OpenERP的更多功能模块, 可以在随后的对需求更明确的情况下逐步地安装到系统中.&lt;/p&gt;

&lt;p&gt;不要一开始就把所有模块都安装上, 应该把部署过程分为一个个小的阶段.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;背景介绍&lt;/h3&gt;

&lt;p&gt;Silkworm公司是一个开展屏幕打印, 刺绣(embroidery)和图形设计业务的公司. 将以此公司为例, 首先实现SO(Sales Order)模块, 将产品(T恤)的销售纳入管理中.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;创建数据库&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://lh5.googleusercontent.com/-znSvr6T_6J4/UyWUxi1Zs5I/AAAAAAAAAOc/k6uwDyRtC3g/s800/OE_create_db.png&quot; alt=&quot;创建数据库&quot; title=&quot;创建数据库&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sales-management&quot;&gt;安装销售管理(Sales Management)模块&lt;/h2&gt;
&lt;p&gt;在模块列表中找到销售管理模块, 安装之.
&lt;img src=&quot;https://lh6.googleusercontent.com/-DFXuwiFC57U/UyWUxjYuNqI/AAAAAAAAAOc/0ZsMWcDYsUE/s800/OE_modules_list.png&quot; alt=&quot;模块列表&quot; title=&quot;模块列表&quot; /&gt;
经过一会的等待, 销售管理安装完成.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;配置会计数据&lt;/h2&gt;
&lt;p&gt;销售管理模块安装后, 显示如下的配置会计数据提示.
&lt;img src=&quot;https://lh4.googleusercontent.com/-PxujzUQ9m1A/UyWWlAaes3I/AAAAAAAAAO0/a0_ibeEqEew/s800/OE_config_accounting.png&quot; alt=&quot;配置会计数据&quot; title=&quot;配置会计数据&quot; /&gt;
选择中国会计科目表, 点击继续, 一会后弹出会计选项配置. 还可以选择”小企业会计科目表”.
&lt;img src=&quot;https://lh3.googleusercontent.com/-8mkKo0ZnUIU/UyWYLbkQ0PI/AAAAAAAAAPM/_RHDs4deLFk/s800/OE_accounting_option.png&quot; alt=&quot;会计选项&quot; title=&quot;会计选项&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;创建第一位客户&lt;/h2&gt;

&lt;p&gt;销售模块安装完成后, 自动打开创建客户功能, 并提示你开始创建第一位客户.
&lt;img src=&quot;https://lh4.googleusercontent.com/-NGkAr0fcWY0/UyWdKZr9dyI/AAAAAAAAAP0/yehuD-56qtc/s800/OE_create_customer.png&quot; alt=&quot;创建客户&quot; title=&quot;创建客户&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;“是一个公司?”&lt;/h3&gt;
&lt;p&gt;如果选择了”是一个公司”, 下方将会在显示额外的信息填写选项.&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;编辑客户信息–销售与采购页&lt;/h3&gt;

&lt;p&gt;客户信息页面的地步分为几个tabs和pages, 这里填写更多的信息. 在销售与采购页, 可以填写这些信息, 例如销售员和各种Email.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh6.googleusercontent.com/-SRJuTpGjrDg/UyWgE4eJNJI/AAAAAAAAAQM/-XW6IdOXg5I/s800/OE_create_customer_salesNpurchases.png&quot; alt=&quot;销售与采购&quot; title=&quot;销售与采购&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 销售员(Salesperson)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过设定销售员可以为这位客户制定一个销售员. 这个字段不是必须的, 如果使用CRM模块的话, 这个字段一般会用到.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 编号(Reference)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编号字段用于处理已有信息系统中的客户编号, 如果没有历史遗留客户数据问题, 这个字段可以用于其他目的, 或者直接留空.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3 语言(Language)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4 日期(Date)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;系统使用这里填写的日期作为得到这个用户的日期, 也可以将这个字段留空.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5 客户(Customer)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;OpenERP使用一种唯一的方法保存人员相关的数据, 所有个体数据保存在同样的表中(res_partner), 无论他们是客户还是供应商. 张三是一个客户, 所以勾选客户checkbox.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6 供应商(Supplier)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个个体可以即是客户又是供应商.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7 有效(Active)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果想不显示一个客户, 但是又不想从DB中删除他, 那么可以用这个”有效”字段来控制.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OpenERP的很多类型的数据中, 都有这个&quot;有效&quot;字段, 可以方便地无效某条数据但不从DB中删除它.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;8 通过Email接收消息(Receive Messages by Email)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设定与客户交流的水平, 以及什么情况下客户收到电子邮件通知.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9 Opt-Out&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Opt-Out标志允许你阻止任何自动的或市场活动相关的电子邮件发送到客户email地址.&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;编辑客户信息–会计页&lt;/h3&gt;

&lt;p&gt;因为添加新客户时必须提供一些潜在的基本信息, 所以需要填写会计页页面的信息. 只有”应收科目”和”应付帐”是必填的.
&lt;img src=&quot;https://lh4.googleusercontent.com/-OOW3nfv2PU4/UyZm517St3I/AAAAAAAAAQo/et5sPGlg3Mc/s800/OE_SO_customer_accounting.png&quot; alt=&quot;会计页&quot; title=&quot;会计页&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 财务结构(Fiscal Position)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;税务状态. OpenERP中有两种: 正常(Normal Taxes)和免税(Tax Exempt). 这个字段不是必须的, 并且在生成sales order时可以重载此项.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 应收科目(Account Receivable)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为这个客户指定默认收账帐号类型. 此字段必填.  &lt;font color=&quot;yellow&quot;&gt;TODO:了解相关的财务知识.&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;This field is required, and the account will be automatically debited when a customer is invoiced. When the invoice is paid, then the accounts receivable account will be credited.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3 客户付款条款(Customer Payment Term)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般不同的客户有不同的付款条款(期限). 默认提供: 马上, 15天, 30天.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4 应收款合计(Total Receivable)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;新客户是0.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5 信用额度(Credit Limit)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;允许对客户建立信用机制, 例如对于新客户, 要求立刻付款, 所以这里的信用额度也是0.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6 Latest Full Reconciliation Date&lt;/strong&gt;
 &lt;font color=&quot;yellow&quot;&gt;TODO:&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7 应付款(Account Payable)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果该客户是一个供货商, 那么使用这里.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8 供应商付款条款(Supplier Payment Term)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于供货商客户.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9 应付款合计(Total Payable)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于供货商客户.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10 银行账号(Bank Accounts)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;屏幕底部, 可以为客户增加银行账号, 点击”添加一个帐号”, 弹出添加银行账号界面进行添加.&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;创建一个产品&lt;/h2&gt;

&lt;h3 id=&quot;product-name&quot;&gt;产品名称(Product Name)&lt;/h3&gt;

&lt;p&gt;Medium White T-Shirt&lt;/p&gt;

&lt;h3 id=&quot;category&quot;&gt;种类(Category)&lt;/h3&gt;

&lt;p&gt;默认会添加到”所有产品”(All products). 可以自定义产品分类.&lt;/p&gt;

&lt;h3 id=&quot;can-be-sole-checkbox&quot;&gt;可销售(Can be Sole) checkbox&lt;/h3&gt;

&lt;p&gt;类似”有效”(Active).&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;创建一个产品–信息页&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1 产品类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分为”消耗品”和”服务”. 服务类型的产品不会再购买订单中创建采购项, 消耗品类型是真实可卖的, 并且将会产生销售订单.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 销售价格&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;16.50&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3 编号(Internal Reference)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;选填, 可以用于企业内部对产品进行编号的机制.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4 EAN13 条码&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;procurements-page&quot;&gt;创建一个产品–Procurements page&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1 成本(Cost)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没有安装购买模块, 也可以为产品指定一个成本. 这个数值将用于财务中的标准股票期权, 并且如果安装了购买模块(purchaseing module), 这个价格作为一个购买订单的基本价格.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 供应商说明(Description for Suppliers)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个字段允许为一个产品指定其作为供应商的描述文本. 在一些工业领域, 提供这样的产品信息是必不可少的.&lt;/p&gt;

&lt;h3 id=&quot;inventory&quot;&gt;创建一个产品–盘点页面(Inventory)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1 状态(Status)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;开发中
常规
生命周期结束
作废
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2 产品经理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以为每种产品指定一个产品经理, 这样做便于产生报表和更加智能的仪表盘. 例如, 一个工程师可以配置他的仪表盘仅显示他作为产品经理的产品.&lt;/p&gt;

&lt;h3 id=&quot;sales&quot;&gt;创建一个产品–销售页面(Sales)&lt;/h3&gt;

&lt;p&gt;这里可以设置质保时间以及报价单上的文本说明.&lt;/p&gt;

&lt;h3 id=&quot;accounting&quot;&gt;创建一个产品–会计页面(Accounting)&lt;/h3&gt;

&lt;p&gt;这里设置税率(客户税和进项税).&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;设置公司信息&lt;/h2&gt;

&lt;p&gt;选择”设置”=&amp;gt;”公司”, 选择”Your Company”进行编辑. 比较简单, 不再记录.&lt;/p&gt;

&lt;h2 id=&quot;sales-order&quot;&gt;输入第一个销售订单(sales order)&lt;/h2&gt;

&lt;p&gt;点击”销售”=&amp;gt;”销售订单”, 点击创建新建一个新的销售订单.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 选择客户&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;选择刚才创建了的张三.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 日期&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3 客户关联单号(Customer Reference)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个值用于与销售相关联, 例如可能希望保存一个该用户怎么获得的引用.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入销售订单的行项&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;点击下方的”增加一个项目(Add a item)”, 将会插入一个新的行, 在这里填写刚才输入的产品以及数量等信息.&lt;/p&gt;

&lt;p&gt;点击保存后, 将显示客户地址, 并且金额的小计(Subtotal), 合计(Total)将计算并显示.&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;理解销售订单工作流程&lt;/h3&gt;

&lt;p&gt;销售订单输入后, 它的状态处于”报价单草稿(Draft Quotation)”状态, 报价单的状态显示在报价单的右上方(OpenERP7). “报价单草稿”=&amp;gt;”报价单发送(Quotation Sent)”=&amp;gt;”已完成(Done)”.&lt;/p&gt;

&lt;p&gt;从这个流程可以看出来, 报价单需要发送才能确认完成. 报价单页面左上方显示当前可以进行的操作.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以邮件发送(Send by Email)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以设定的Email地址发送报价单copy.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;打印&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;生成一个PDF格式的文档.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;确认订单(Confirm Sale)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;订单确认后, 报价单将转变为一个销售订单, 并进入到后续的销售流程中.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;取消报价(Cancel Quotation)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;取消订单终止报价工作流, 但不会被删除该报价单, 这些数据用于归档,&lt;/p&gt;

&lt;h3 id=&quot;invoicing-the-sale&quot;&gt;开具销售发票(Invoicing the sale)&lt;/h3&gt;

&lt;p&gt;不同的业务类型在确认销售订单后会有不同的工作流程. 在本例中, 下一步是开具发票. 确认订单后, 点击”生成发票(Create Invoic)”按钮, 将显示一个”开票订单(Invoice Order)”窗口, 选择开票类型, 然后生成发票即可.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生成发票(Creating the invoice)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;初始生成的发票处于”草稿(Draft)”状态, 点击”查看发票”=&amp;gt;”使其有效(Validate)”确认发票并进入到下一个流程.&lt;/p&gt;

</description>
                <link>http://www.jeffzhang.cn/openerp/2014/03/16/OpenERP-Notes%283%29.-Starting-Your-First-Company</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/03/16/OpenERP-Notes(3).-Starting-Your-First-Company</guid>
                <pubDate>2014-03-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Ml (2). Decision Trees</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;下图是一个假想的邮件分类决策树.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh6.googleusercontent.com/-6AQJcHDG3Ps/UyJQG3oQ5TI/AAAAAAAAANs/IdP8KE3Yb5s/s800/decision-trees.png&quot; alt=&quot;A decision tree in flowchart form&quot; title=&quot;A decision tree in flowchart form&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;优点: 低计算复杂度, 结果容易理解, 缺失值不敏感, 能够处理不相关特征数据;
缺点: 易过度适应(Prone to overfitting);
适用: 数值, 标称值.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;适用于:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据实例由”属性-值”对构成;&lt;/li&gt;
  &lt;li&gt;目标函数具有离散的输出值;&lt;/li&gt;
  &lt;li&gt;可能需要析取的描述(disjunctive description), 因为决策树自然地代表了析取表达式;&lt;/li&gt;
  &lt;li&gt;训练数据可能包含错误, 决策树对错误具有良好的健壮性;&lt;/li&gt;
  &lt;li&gt;训练数据可以包含缺少属性值的实例, 例如某些样本缺少重量的属性数据.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;构造决策树&lt;/h2&gt;

&lt;p&gt;首先, 找到用于划分数据类别的特征项; 然后, 以此特征项分割不同类数据; 最后, 判断分割后的数据是否还能够分割, 如果可以, 再次重复这个过程.&lt;/p&gt;

&lt;p&gt;伪码:
&lt;script src=&quot;https://gist.github.com/jeffzhangfly/9540406.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;流程&lt;/h3&gt;

&lt;p&gt;套用机器学习的几个步骤: 收集数据, 准备输入数据, 分析输入数据, 训练算法, 测试算法, 使用算法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 收集: 任意方法;
2. 准备: 连续型数据需要首先离散化;
3. 分析: 任意方法, 构造完成后visually inspect the tree;
4. 训法: 构造一个决策树的数据结构;
5. 测试: 计算错误率;
6. 使用: ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;信息增益&lt;/h3&gt;

&lt;p&gt;划分数据集要以将数据变得更有序/有组织(more organized)为标准. 使用信息论,检测数据分割前后的信息变化, 分割前后信息发生的变化即信息增益, 以信息增益最高为标准, 可以确定采用哪个特征来分隔数据最好.&lt;/p&gt;

&lt;h3 id=&quot;entropy&quot;&gt;熵(entropy)&lt;/h3&gt;

&lt;p&gt;熵的概念最早起源于物理学，用于度量一个热力学系统的无序程度。在信息论里面，熵是对不确定性的测量。&lt;/p&gt;

&lt;p&gt;如果某个事物可能的分类有多个, 那么事物属于某个类别$x_i$的信息定义为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;l(x_i)=-\log_2p(x_i)&lt;/script&gt;

&lt;p&gt;$p(x_i)$是事物属于这个类别的概率.&lt;/p&gt;

&lt;p&gt;熵定义为信息的期望值, 即所有位置的所有信息的期望值.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H=-\sum_{i=1}^np(x_i)\log_2p(x_i)&lt;/script&gt;

&lt;h3 id=&quot;section-4&quot;&gt;算法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/zh/ID3算法&quot; title=&quot;ID3&quot;&gt;ID3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/C4.5算法&quot; title=&quot;C4.5&quot;&gt;C4.5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;过度拟合&lt;/h3&gt;

&lt;p&gt;定义: 给定一个假设空间$H$, 一个假设$h\in H$, 如果存在其他的假设$h^{\prime}\in H$, 使得在训练样例上$h$的错误率比$h^{\prime}$小, 但在整体实例分布上$h^{\prime}$的错误率比$h$小, 那么就说假设$h$过度拟合(overfit)训练数据.&lt;/p&gt;

&lt;p&gt;解决过度拟合的思路分两类:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在完美分类训练数据之前就停止树的增长;&lt;/li&gt;
  &lt;li&gt;后修剪法(post-proune), 即允许树过度拟合, 然后再对这个树进行修剪.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最普遍的一种方法: 训练和验证集(training and validation set)法. 可用的数据被分为训练集合和验证集合两个样例集合, 前者用来形成学习到的假设, 后者用来对假设并进行评估和修剪.&lt;/p&gt;
</description>
                <link>http://www.jeffzhang.cn/machine%20learning/2014/03/14/ML-%282%29.-Decision-Trees</link>
                <guid>http://www.jeffzhang.cn/machine%20learning/2014/03/14/ML-(2).-Decision-Trees</guid>
                <pubDate>2014-03-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Notes(2). Setting Up Openerp</title>
                <description>
&lt;h2 id=&quot;opererp&quot;&gt;了解OperERP架构&lt;/h2&gt;

&lt;h3 id=&quot;postgresql&quot;&gt;PostgreSQL&lt;/h3&gt;
&lt;p&gt;开源, 跨平台的ORDMS(object relational database management system), 在BSD风格许可证下发行. 更多信息点击&lt;a href=&quot;http://zh.wikipedia.org/wiki/PostgreSQL&quot; title=&quot;中文wiki PostgreSQL词条&quot;&gt;这里&lt;/a&gt;查看.&lt;/p&gt;

&lt;h3 id=&quot;writing-code-with-python&quot;&gt;Writing code with Python&lt;/h3&gt;

&lt;h3 id=&quot;following-the-mvc-design&quot;&gt;Following the MVC design&lt;/h3&gt;

&lt;h3 id=&quot;designing-models&quot;&gt;Designing models&lt;/h3&gt;

&lt;p&gt;数据库结构由OpenERP模块定义, 当安装模块时, OpenERP框架根据实体模型定义自动地创建所需的表结构. 并且, OpenERP提供一个web接口, 通过它不需要修改OpenERP源代码就可以扩展数据模型.&lt;/p&gt;

&lt;h3 id=&quot;rendering-views&quot;&gt;Rendering views&lt;/h3&gt;

&lt;p&gt;OpenERP中的每个view都是使用XML定义的, OpenERP框架负责根据XML内容在浏览器上渲染页面.&lt;/p&gt;

&lt;h3 id=&quot;authoring-controllers&quot;&gt;Authoring controllers&lt;/h3&gt;
&lt;p&gt;架构中的控制器组件可以实现OpenERP应用的业务逻辑和工作流规则. OpenERP中的控制器组件使用Python编写, 保存为OpenERP模块中的一个对象.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;安装&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;安装包安装&lt;/h3&gt;

&lt;p&gt;简单, 省略.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;源码安装&lt;/h3&gt;

&lt;p&gt;首先安装OpenERP的依赖, 例如PostgreSQL, Python及需要的Python库. 然后就可以开始源码安装.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装bzr:&lt;/p&gt;

    &lt;p&gt;$ sudo apt-get install bzr      (Linux)&lt;/p&gt;

    &lt;p&gt;$ sudo brew install bzr         (Mac)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取Installer并执行:&lt;/p&gt;

    &lt;p&gt;$ bzr cat -d lp:~openerp-dev/openerp-tools/trunk setup.sh | sh&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装OpenERP 7.0源码&lt;/p&gt;

    &lt;p&gt;$ make init-v70&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>http://www.jeffzhang.cn/openerp/2014/03/13/OpenERP-Notes%282%29.-Setting-Up-OpenERP</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/03/13/OpenERP-Notes(2).-Setting-Up-OpenERP</guid>
                <pubDate>2014-03-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Ml (1). K— Nearest Neighbors</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;k-近邻(k-Nearest Neighbors, kNN)算法通过测量各个特征值之间的距离来进行分类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;优点: 精度高, 对异常值不敏感, 无数据输入假定.
缺点: 计算复杂, 空间复杂.
使用数值范围: 数值, 标称值(nominal values, 标称类型的变量取值是有限的, 例如{真,假};{鸟类, 鱼类}等).
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;已有一个样本数据集(训练数据集), 其中每个数据都标记了它归于哪一类. 当给定一个新的没有归类信息的数据时, 从训练数据集中找出最相似的一些数据(the nearest neighbors), 根据它们的类别确定分类. 只选择前$k$个最相似的数据, 所以称为k-近邻(一般$k$不超过20). 从$k$个最相似数据中找出出现次数最多的类别, 确定新数据的分类.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;流程&lt;/h2&gt;

&lt;p&gt;套用机器学习的几个步骤: 收集数据, 准备输入数据, 分析输入数据, 训练算法, 测试算法, 使用算法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 收集: 任意方法;
2. 准备: 为计算距离准备数值型的数据, 最好是结构化数据;
3. 分析: 任意方法;
4. 训法: kNN不需要训练;
5. 测试: 计算错误率;
6. 使用: ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;伪码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;输入: 欲分类数据X
输出: X的类别
算法:
1. 计算训练集中的每个数据到X的距离;
2. 按距离升序排序训练集中数据;
3. 选出距离最小的k个数据;
4. 统计k个数据的分类;
5. 返回包含数据最多的那个类别(作为X分类).
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://www.jeffzhang.cn/machine%20learning/2014/03/13/ML-%281%29.-k%E2%80%94-Nearest-Neighbors</link>
                <guid>http://www.jeffzhang.cn/machine%20learning/2014/03/13/ML-(1).-k—-Nearest-Neighbors</guid>
                <pubDate>2014-03-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Ml (0). Start</title>
                <description>
&lt;p&gt;近期工作需要, 计划整理一个机器学习的算法库. 过一遍&lt;em&gt;Machine Learning in Action&lt;/em&gt;, 在此记录笔记.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh6.googleusercontent.com/-m-HikoUUo8A/UyEps2nxZMI/AAAAAAAAANU/TXoGh_DtyoU/s800/mlinaction.png&quot; alt=&quot;Cover of Machine Learning in Action&quot; title=&quot;Cover of Machine Learning in Action&quot; /&gt;&lt;/p&gt;
</description>
                <link>http://www.jeffzhang.cn/machine%20learning/2014/03/12/ML-%280%29.-Start</link>
                <guid>http://www.jeffzhang.cn/machine%20learning/2014/03/12/ML-(0).-Start</guid>
                <pubDate>2014-03-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Notes (1). Intro</title>
                <description>
&lt;h2 id=&quot;erp&quot;&gt;1. 通用ERP模块&lt;/h2&gt;

&lt;p&gt;ERP系统核心应用一般包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sales Orders(SO)&lt;/li&gt;
  &lt;li&gt;Purchase orders(PO)&lt;/li&gt;
  &lt;li&gt;Accounting and finance(General Ledger, GL)&lt;/li&gt;
  &lt;li&gt;Manufacturing Resource Planning(MRP)&lt;/li&gt;
  &lt;li&gt;Customer Relationship Management(CRM)&lt;/li&gt;
  &lt;li&gt;Human Resources(HR)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sales-ordersso&quot;&gt;1.1 Sales Orders(SO)&lt;/h3&gt;
&lt;p&gt;Sales Orders(SO), are documents that a business generates when they sell products and services to a customer. The SO module usually will allow management of customers and products to optimize efficiency for data entry of the sales order.&lt;/p&gt;

&lt;h3 id=&quot;purchasing-products-from-suppliers&quot;&gt;1.2 Purchasing products from suppliers&lt;/h3&gt;
&lt;p&gt;Purchase Order(PO), are documents that a business generates when they purchase products from a vendor. The PO module will typically include management of venders(also called suppliers) as well as management of the products that vendor carries.&lt;/p&gt;

&lt;h3 id=&quot;accounting-and-finance&quot;&gt;1.3 Accounting and finance&lt;/h3&gt;
&lt;p&gt;Accounting and finance modules intergrate with an ERP
system to organize and report business transactions. In many ERP systems, the accounting and finance module is known as GL for General Ledger.&lt;/p&gt;

&lt;h3 id=&quot;mrp&quot;&gt;1.4 MRP&lt;/h3&gt;
&lt;p&gt;The Manufacturing Resource Planning(MRP) module manages all the various business operations that go into the manufacturing of products.&lt;/p&gt;

&lt;h3 id=&quot;crm&quot;&gt;1.5 CRM&lt;/h3&gt;
&lt;p&gt;A Customer Relationship Management(CRM) module assists a business in better handling the interactions they may have with each customer.&lt;/p&gt;

&lt;h3 id=&quot;hr&quot;&gt;1.6 HR&lt;/h3&gt;
&lt;p&gt;Human Resource(HR) modules, manage the workforce or employee-related information in business.&lt;/p&gt;

&lt;h2 id=&quot;opererp&quot;&gt;2. OperERP提供的其他模块&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Point of Sale&lt;/li&gt;
  &lt;li&gt;Project Management&lt;/li&gt;
  &lt;li&gt;Analytic Accounting&lt;/li&gt;
  &lt;li&gt;Document Management System&lt;/li&gt;
  &lt;li&gt;Outlook Plugin&lt;/li&gt;
  &lt;li&gt;Country-Specific Accounting Templates&lt;/li&gt;
  &lt;li&gt;OpenOffice Report Designer
*&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://www.jeffzhang.cn/openerp/2014/03/11/OpenERP-Notes-%281%29.-Intro</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/03/11/OpenERP-Notes-(1).-Intro</guid>
                <pubDate>2014-03-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Openerp Notes (0). Start</title>
                <description>
&lt;h2 id=&quot;start-here&quot;&gt;Start here!&lt;/h2&gt;

&lt;h3 id=&quot;working-with-openerp&quot;&gt;Working with OpenERP&lt;/h3&gt;
&lt;p&gt;Learn to utilize OpenERP to transform and streamline your business&lt;/p&gt;

&lt;!--![Face](https://lh5.googleusercontent.com/-GripjIMCLVE/Ux8HdGidWII/AAAAAAAAAL4/obPzlzxwhp4/s800/working_with_openerp.png &quot;Working with OpenERP&quot;)--&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Working with OpenERP&lt;/em&gt; provides a comprehensive walkthrough for installing, configuring, and implementing OpenERP in real-world business environments, understanding the value of ERP systems and &lt;strong&gt;best practice&lt;/strong&gt; approaches for getting a system up and running in your organization.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;This book is for anyone that is interested in implementing an ERP system in a business organization, and IT professionals looking to get a functional understanding of OpenERP.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                <link>http://www.jeffzhang.cn/openerp/2014/03/11/OpenERP-Notes-%280%29.-Start</link>
                <guid>http://www.jeffzhang.cn/openerp/2014/03/11/OpenERP-Notes-(0).-Start</guid>
                <pubDate>2014-03-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Yaahp</title>
                <description>
&lt;p&gt;&lt;em&gt;yaahp&lt;/em&gt; is a decision analysis software based on analytic hierarchical process (AHP).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-jbDvxKt4C0I/Uyuyb6vQsPI/AAAAAAAAAR4/Nt6r9byJjV8/s800/main.png&quot; alt=&quot;Model modify&quot; title=&quot;Model modify&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh4.googleusercontent.com/-8UfCRL8ZsgY/Uyuyb41R3lI/AAAAAAAAARw/loIbQ0oGZ_8/s800/main_matrix_input.png&quot; alt=&quot;Matrix&quot; title=&quot;Matrix&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh5.googleusercontent.com/-d7Mk6PwUSZU/Uyuyb12GVCI/AAAAAAAAARo/SGFdUzkX6yk/s800/sensitive.png&quot; alt=&quot;Sensitive&quot; title=&quot;Sensitive&quot; /&gt;&lt;/p&gt;
</description>
                <link>http://www.jeffzhang.cn/mcda/2012/05/06/yaahp</link>
                <guid>http://www.jeffzhang.cn/mcda/2012/05/06/yaahp</guid>
                <pubDate>2012-05-06T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
